<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[UE4笔记（1） 源码编译和安装]]></title>
      <url>http://yoursite.com/2017/01/21/UE4%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<blockquote>
<p>序言<br>近来UE4渐渐有了抬头的趋势，并且因为其在VR游戏设计中表现突出的渲染性能而饱受开发者青睐，更令人惊叹不已的是这个引擎的源码是开源的，这对于希望研究引擎底层代码的码农来说，优秀得有点过分啦。</p>
</blockquote>
<a id="more"></a>
<hr>
<p>###一、引擎安装：<br>关于引擎安装，其实有两种方式：</p>
<ul>
<li>通过官方提供的Laucher下载引擎、工具和资源，具体步骤：登录Epic Games账号后，打开<a href="https://www.unrealengine.com/dashboard" target="_blank" rel="external">https://www.unrealengine.com/dashboard</a>，在第一项中选择平台下载安装引擎所需的EpicGamesLauncherInstaller；<br><img src="http://img.blog.csdn.net/20170116153109625" alt="获取引擎"></li>
<li>下载Github官方源码，然后使用Visual Studio进行编译得到引擎工具。</li>
</ul>
<p>###二、UE4源码下载：<br>打开UE4的<a href="https://www.unrealengine.com" target="_blank" rel="external">官网</a>链接，注册一个Epic Games的个人账号。登录账号后，参考官方<a href="https://www.unrealengine.com/zh-CN/ue4-on-github" target="_blank" rel="external">如何链接您的Github账户以下载虚幻引擎4源代码</a>的相关说明，即可通过github下载完整的Unreal Engine源码。</p>
<hr>
<p>###三、源码编译：<br>下载源码后，解压到<strong>不包含中文</strong>的本地目录下：<br><img src="http://img.blog.csdn.net/20170116153304065" alt="目录结构"></p>
<ul>
<li>编译需要借助Visual Studio编程工具，所以需提前安装2013版或2012版的VS；</li>
<li>在解压根目录找到<code>GenerateProjectFiles.bat</code>文件，双击此文件即可生成源码项目的<code>UE4.sh</code>文件；</li>
<li>双击上述生成的.sh文件，会在VS中打开源码，带导入完毕，选中<code>UE4.sh</code>，<code>右键</code>-&gt;<code>生成</code>，等待编译完成。</li>
<li>生成完毕之后，在当前源码根目录下，打开<code>Engine\Binaries</code>，会有适用于不同平台的的文件夹，打开win64，打开<code>UE4Editor.exe</code>即可打开UE4编辑器。</li>
</ul>
<hr>
<p>###四、缺陷说明：<br>使用源码编译的引擎工具有一点不足，那就是访问MarketPlace时必须通过Laucher，而只要安装并启动了官方的Laucher，则会自动下载最新的引擎工具包（大概7G），那此时机器上就会同时存在两个版本的UE4（官方Laucher下载安装的和自己编译得到的），不过使用官方Laucher在MarketPlace中下载的资源，在自己编译得到的引擎工具中是可以正常使用的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CG手绘初学笔记（3）从线稿到上色]]></title>
      <url>http://yoursite.com/2016/11/15/CG%E6%89%8B%E7%BB%98%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E4%BB%8E%E7%BA%BF%E7%A8%BF%E5%88%B0%E4%B8%8A%E8%89%B2/</url>
      <content type="html"><![CDATA[<p>虽然学习画画没有捷径，但我们也应该避免走弯路，使用比较科学的绘画思路往往能使得绘画这件事情更加直观。</p>
<a id="more"></a>
<h3 id="线稿"><a href="#线稿" class="headerlink" title="线稿"></a>线稿</h3><p>通常有两种方式来获取线稿：</p>
<ul>
<li>在纸上用铅笔完成线稿，然后通过扫描输入到绘画软件中；</li>
<li>直接使用绘画板（手绘板）在软件上进行线稿绘制。</li>
</ul>
<p>通过扫描铅笔线稿获取线稿时，需要对文件进行一些处理，从而提取出优质的线稿，以便于后面的上色工作，这里以Photoshop为例，提取线稿快捷键组合：<br>Ctrl+A -&gt; Ctrl+C -&gt; Ctrl+V -&gt; Q -&gt; Ctrl+Shift+I -&gt; Ctrl+C -&gt; Ctrl+V(此步骤重复2到3次)</p>
<h3 id="上色"><a href="#上色" class="headerlink" title="上色"></a>上色</h3><p>上色的技法关键在于光影和素描关系的把握，而非色彩多么的丰富</p>
<h4 id="光影："><a href="#光影：" class="headerlink" title="光影："></a>光影：</h4><p>光影的产生：当光线落在物体性状上，从而按照逻辑关系创造出来光和影，也就是物体的<strong><code>黑白灰</code></strong>。主要分析两点：<strong>光与影的分布</strong>和<strong>光与影的形状</strong>。</p>
<p>色彩：<br>反光的补色（灰蓝色）——明暗交界线的固有色（暖红灰色）——亮部的浅灰色（浅灰红）<br>一般暗部的纯度都比亮部的纯度要高</p>
<h4 id="Photoshop底色法："><a href="#Photoshop底色法：" class="headerlink" title="Photoshop底色法："></a>Photoshop底色法：</h4><p>在一个底色的基础上逐步绘制出人物的造型，底色起到规范色调的作用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity3D —— 小地图制作插件NJG MiniMap]]></title>
      <url>http://yoursite.com/2016/10/11/Unity3D-%E2%80%94%E2%80%94-%E5%B0%8F%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C%E6%8F%92%E4%BB%B6NJG-MiniMap/</url>
      <content type="html"><![CDATA[<p>在很多实时PVP对战游戏（如：英雄联盟、王者荣耀等）的战斗场景中，都会有一个小地图，用于实时地显示一些比较重要因素，例如：队友和对手位置、存活炮塔位置、Boss出生死亡情况等。</p>
<h3 id="NJG-MiniMap插件："><a href="#NJG-MiniMap插件：" class="headerlink" title="NJG MiniMap插件："></a>NJG MiniMap插件：</h3><h4 id="1-下载地址："><a href="#1-下载地址：" class="headerlink" title="1.下载地址："></a>1.下载地址：</h4><p>NJG下载地址：链接：<a href="http://pan.baidu.com/s/1kTkzxxt" target="_blank" rel="external">http://pan.baidu.com/s/1kTkzxxt</a> 密码：jwqy</p>
<a id="more"></a>
<h4 id="2、NGUI-Version："><a href="#2、NGUI-Version：" class="headerlink" title="2、NGUI Version："></a>2、NGUI Version：</h4><p>下载好插件后，导入到Unity中不用说，导入后可以看到NinjutsuGames文件夹，插件的所有内容都在这个文件夹下，找到NinjutsuGames/NJG MiniMap目录下的NGUI Version包双击，它会生成一个<code>NGUI Version</code>文件夹：</p>
<p><img src="http://i.imgur.com/R6Glx1B.png" alt=""></p>
<h4 id="3、实例："><a href="#3、实例：" class="headerlink" title="3、实例："></a>3、实例：</h4><p>可以在NGUI Version/Examples/Scene2中查看示例，打开示例场景<code>Example-BigTerain</code>查看效果，但是好像会有一个BUG，查看世界地图的时候会出现显示错误，可看到图中红色箭头部分：</p>
<p><img src="http://i.imgur.com/p4SuWBj.png" alt=""><br><img src="http://i.imgur.com/vbAVmJm.png" alt=""></p>
<h3 id="创建自己的Demo："><a href="#创建自己的Demo：" class="headerlink" title="创建自己的Demo："></a>创建自己的Demo：</h3><p>看过官方的示例，我们可以自己创建一个场景来试试，这里我就不搭建自己的场景，直接用NJG MiniMap搭建好的场景来做：</p>
<h4 id="1-新建场景："><a href="#1-新建场景：" class="headerlink" title="1.新建场景："></a>1.新建场景：</h4><p>新建一个场景，这里命名为scene9，找到<code>NinjutsuGames\NJG MiniMap\ExamplesAssets\Prefabs</code>目录下的<code>Scene.prefab</code>直接拖动到Hierarchy栏中，运行可以看到效果如下,这时候有些对象里可能会出现如下错误：</p>
<p><img src="http://i.imgur.com/rjBtQFX.png" alt=""><br><img src="http://i.imgur.com/R740xO4.png" alt=""></p>
<p>这是因为预设里面已经绑定了相关小地图的脚本，但是现在我们还没有添加相关小地图的NGUI内容，有两个解决方法：</p>
<ul>
<li>（1）直接删掉这个脚本；</li>
<li>（2）待后续添加相关内容即可</li>
</ul>
<p>这里把Scene里全部对象的这个脚本都删掉；</p>
<h4 id="2添加小地图"><a href="#2添加小地图" class="headerlink" title="2添加小地图:"></a>2添加小地图:</h4><p>小地图是用NGUI创建的</p>
<ul>
<li>先用NGUI创建一个2D UI：NGUI——&gt;Create——&gt;2D UI：</li>
<li>把NinjutsuGames\NJG MiniMap\NGUI Version\Prefabs目录下的<code>NJG MiniMap.prefab</code>文件直接拖动到UI Root下面，点击UI Root下的Camera，可以在Scene的右下角看到小地图的缩略版：</li>
</ul>
<p>这时候我们点击运行，可以看到小地图已经出现，截图如下：</p>
<p><img src="http://i.imgur.com/hMgtWtm.png" alt=""></p>
<h4 id="3-添加其他物体："><a href="#3-添加其他物体：" class="headerlink" title="3.添加其他物体："></a>3.添加其他物体：</h4><p>小地图中没有任何标识，我们需要为小地图创建主角对象以及一些敌方怪物啊、NPC等等。在目录NinjutsuGames\NJG MiniMap\Common\Scripts\Core找到脚本<code>NJGMapItem.cs</code>，添加到要标识的对象上，在这个场景中我们以Scene中的<code>_Player</code>为例，将脚本添加到<code>_Player</code>组件中，然后选择NJGMap Item(Script)中的Market Type选项，这里我们选为Me，就可以在小地图中看到表示_Player对象的标识了：</p>
<p><img src="http://i.imgur.com/ACoSWra.png" alt=""></p>
<h4 id="4-自定义图标："><a href="#4-自定义图标：" class="headerlink" title="4.自定义图标："></a>4.自定义图标：</h4><p>我们还可以选择自定义图标，选择_Player的NJGMap Item组件中的<code>Edit NJG MiniMap</code>来进行编辑：</p>
<p><img src="http://i.imgur.com/h97uTEG.png" alt=""></p>
<p>如下图：</p>
<p><img src="http://i.imgur.com/fQ4KPzi.png" alt=""></p>
<ul>
<li>Altas选择自定义图标所在的图集；</li>
<li>点击Add New添加新的Market Type；</li>
<li>Marker Type设置当前标识名；</li>
<li>Icon Sprite就是选择对应的图标了；</li>
</ul>
<h4 id="5-分层编辑："><a href="#5-分层编辑：" class="headerlink" title="5.分层编辑："></a>5.分层编辑：</h4><p>按步骤3中修改对应的Marker Type的名字即可，效果如下：</p>
<p><img src="http://i.imgur.com/uCcRIE2.png" alt=""></p>
<h4 id="6-额外功能："><a href="#6-额外功能：" class="headerlink" title="6.额外功能："></a>6.额外功能：</h4><p>在小地图中还可以添加迷雾效果：<br>选中UI Root下的NJG MiniMap，找到NJGMap组件中的FOW项，勾选上Enabled项：</p>
<p><img src="http://i.imgur.com/nq9ZiH5.png" alt=""></p>
<p>这时候小地图已经被迷雾覆盖，还需要设置对象物体的可视，勾选_Player中NJGMap Item中的Reveal FOW选项，调节可视距离即可，可视距离为0的话默认全部可视：</p>
<p><img src="http://i.imgur.com/H8CrEee.png" alt=""></p>
<h4 id="7、最终结果："><a href="#7、最终结果：" class="headerlink" title="7、最终结果："></a>7、最终结果：</h4><p><img src="http://i.imgur.com/Cl9Ru6r.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CG手绘初学笔记（2）预备知识]]></title>
      <url>http://yoursite.com/2016/09/21/CG%E6%89%8B%E7%BB%98%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>学习CG对于初学者来说，并非一朝一夕就能掌握的，也需要循序渐进的过程，通过大量的了解，学习过程大致如下：</p>
<h3 id="一、线条："><a href="#一、线条：" class="headerlink" title="一、线条："></a>一、线条：</h3><ul>
<li>手绘线条：即直接在纸上练习各种基本的手绘线条，当达到一定熟练程度之后，进入下一个阶段；</li>
<li>板绘线条：在纸上绘制线条很熟练之后，还需要在手绘板上进行练习，刚开始当然也是线条的练习；</li>
<li>临摹：包括线条的临摹和上色的临摹；</li>
</ul>
<a id="more"></a>
<p>我参考的是You Tube（需要翻墙，Mac系统可以借助免费软件”<code>蓝灯</code>“）上的一个国外视频系列：</p>
<ul>
<li><a href="https://www.youtube.com/user/JSolorzanoArts1/videos?shelf_id=4&amp;sort=dd&amp;view=0" target="_blank" rel="external">Sketch 2 Draw</a></li>
<li><a href="https://www.youtube.com/channel/UCzM8cfTU666_-aFNulLEx2Q" target="_blank" rel="external">LethalChris Drawing</a></li>
<li><a href="https://www.youtube.com/channel/UCXyk40gJRzA9WJ27UA1xlgQ" target="_blank" rel="external">Emmy Kalia</a></li>
</ul>
<h3 id="二、需要掌握的内容："><a href="#二、需要掌握的内容：" class="headerlink" title="二、需要掌握的内容："></a>二、需要掌握的内容：</h3><ul>
<li>素描：所有单色绘画都可以归属于素描范畴；</li>
<li>色彩：油画和水粉画都能够帮助练习色彩，但是油画从工具到绘画都比较繁杂，所以一般通过水彩画练习比较合适；</li>
<li>板绘：手绘技巧达到一定的熟练程度之后，可以开始使用数绘板来进行绘画</li>
<li>人体：由于在原画设计过程中，对于一些人物和怪物的设计时，需要参考人体的肌肉骨骼等结构</li>
</ul>
<h3 id="三、画画起稿方式："><a href="#三、画画起稿方式：" class="headerlink" title="三、画画起稿方式："></a>三、画画起稿方式：</h3><ul>
<li>线稿：用线条描绘出设计稿的轮廓</li>
<li>厚图：直接用笔刷色块绘制，通过修改笔刷尺寸和颜色进行细化</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CG手绘初学笔记（1）]]></title>
      <url>http://yoursite.com/2016/09/20/CG%E6%89%8B%E7%BB%98%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>其实从小学开始就酷爱临摹各种卡通人物，虽然不能媲美专业级别，但是自我感觉还是可以的（也不知道哪来的自信）。感觉与其把工作之余的时间浪费掉，还不如用来学点自己感兴趣的东西更实在一些，就当做是业余爱好吧，不是有这么一句话吗？——“灵魂和身体，总得有一个在路上”</p>
<h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><h4 id="1-手绘板："><a href="#1-手绘板：" class="headerlink" title="1.手绘板："></a>1.手绘板：</h4><p>询问了专业美术意见之后，在<a href="http://estore.wacom.com.cn/" target="_blank" rel="external">Wacom官网</a>选择了适合初学者的手绘板，型号：</p>
<ul>
<li><strong>学习板One By Wacom CTL-471/K0-F</strong>  300元左右的价位</li>
<li><strong>学习板One By Wacom CTL-671/K0-F</strong>  600元左右的价位<br><img src="http://i.imgur.com/YtcCeL6.png" alt=""></li>
</ul>
<a id="more"></a>
<h4 id="2-绘图软件："><a href="#2-绘图软件：" class="headerlink" title="2.绘图软件："></a>2.绘图软件：</h4><p>作为一个初学者，一切都要以省钱为目的，所以找到了这个软件：<a href="http://www.udongman.cn/index.php?m=product&amp;c=youman" target="_blank" rel="external">优漫</a>，关键就是因为它是免费的！！！</p>
<p>官方介绍：优漫是国内唯一一款专业漫画绘制软件，拥有多种功能非凡的笔、尺子等工具，而网点纸编辑、2DLT/3DLT等特色功能更可给予用户快速流畅的创作体验。<br><img src="http://i.imgur.com/30T8Fjb.png" alt=""></p>
<h4 id="3-素材网站："><a href="#3-素材网站：" class="headerlink" title="3.素材网站："></a>3.素材网站：</h4><ul>
<li><a href="http://www.pixiv.net/" target="_blank" rel="external">P站</a></li>
</ul>
<h3 id="结束语："><a href="#结束语：" class="headerlink" title="结束语："></a>结束语：</h3><p>反正人生的意义就在于瞎折腾嘛，总比混吃等死要好一些，待续……</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《Unity Shaders and Effects Cookbook》读书笔记1]]></title>
      <url>http://yoursite.com/2016/09/19/%E3%80%8AUnity-Shaders-and-Effects-Cookbook%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</url>
      <content type="html"><![CDATA[<p>最近在深入学习Unity的ShaderLab，起初看了很多别人的博客，但是内容都比较杂乱零散，想着应该找本书类系统学习一番，经过搜索找到了这本书<strong>《Unity Shaders and Effects Cookbook》</strong>，是当前对于Unity的Shader知识有比较系统介绍的一本书，本书也有中文翻译版，名称为<strong>《Unity着色器与屏幕特效开发秘笈》</strong>，作者是<strong>Kenny Lammers</strong>。</p>
<p><img src="http://i.imgur.com/0S2JOfR.png" alt=""></p>
<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>根据书的概述，阅读本书将学到模拟人体皮肤的着色器、处理动态反射的着色器、三维场景中的渲染次序等，同时也将学习如何开发后期特效，如夜视、反射等。</p>
<a id="more"></a>
<h3 id="章节概述："><a href="#章节概述：" class="headerlink" title="章节概述："></a>章节概述：</h3><ul>
<li>第1章：Unity中构建一个着色器和着色器编写的基础知识，学习如创建默认的<strong>漫反射光照</strong>，从游戏的角度提供创建自定义漫反射光照的技巧；</li>
<li>第2章：介绍如何利用<strong>纹理</strong>来创建不同的特效，学习如何利用着色器在精灵表单（Sprite Sheet）上实现动画纹理，以及如何利用纹理的不同通道，让着色器更有效率；</li>
<li>第3章：创建应用最广泛的高光类型——Blinn和Phong时所需的知识，学习如何应用这些着色器效果来创建蒙版镜面、金属镜面，并学习如何创建各向异性<strong>镜面</strong>的技术；</li>
<li>第4章：把反射技术写入着色器中，从Unity3D着色器中反射的基础到如何使用C#创建简单的自定义动态<strong>反射系统</strong>；</li>
<li>第5章：创建更复杂的着色器，学习如何创建自定义<strong>光照模型</strong>来实现自定义类型的表面，可以创建自己的皮肤着色器、发光球体着色器以及车辆喷漆着色器；</li>
<li>第6章：介绍<strong>透明度</strong>，在游戏制作的过程中，透明度已经成为一项必要的技术，在一定程度上，几乎所有游戏都需要使用透明度，如：图形用户界面（GUI）、树叶、贴花等。本章将学习如何使用Unity3D中的透明度，已经使用透明度时如何处理可能发生的任何问题；</li>
<li>第7章：如何访问存储在3D网格中的每个顶点信息，学习如何得到<strong>顶点信息</strong>，并在着色器中使用这些信息实现诸如纹理混合和动画的效果；</li>
<li>第8章：介绍利用Unity内置标记和内置值来<strong>减少着色器内存开销</strong>的方法，这对于我们处理移动平台上的着色器特别重要；</li>
<li>第9章：学习<strong>重用代码</strong>的必要性，重用代码可以让着色器的编写更有效率。如何创建自定义CgInclude文件来存储需要重用的重复代码；</li>
<li>第10章：从现代游戏如何利用<strong>屏幕特效</strong>（有时也称为后期特效）开始，到如何改变一个游戏的最终渲染效果。学习如何创建自己的屏幕特效，并了解如何添加颜色调整以及纹理叠加背后的秘密，从而为你的游戏制造出不一样的视觉外观；</li>
<li>第11章：屏幕特效深入，学习如何在游戏中增强游戏氛围。学习如何创建一种老电影的屏幕特效以及夜视的屏幕特效。</li>
</ul>
<h3 id="预备工作："><a href="#预备工作：" class="headerlink" title="预备工作："></a>预备工作：</h3><p>需要用到几个软件：</p>
<ul>
<li>Unity3D（10和11章需要使用专业版Unity）</li>
<li>3D建模软件，如Maya、Max或Blender</li>
<li>2D图像编辑软件，如Photoshop或Gimp</li>
</ul>
<h3 id="额外资源："><a href="#额外资源：" class="headerlink" title="额外资源："></a>额外资源：</h3><p>本书中的一些效果图，可以通过下一网站下载：<a href="https://www.packtpub.com/sites/default/files/downloads/5084OT_Images.pdf" target="_blank" rel="external">https://www.packtpub.com/sites/default/files/downloads/5084OT_Images.pdf</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity3D —— protobuf网络框架]]></title>
      <url>http://yoursite.com/2016/09/19/Unity3D-protobuf%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>protobuf是google的一个开源项目，主要的用途是：</p>
<ul>
<li>数据存储（序列化和反序列化），这个功能类似xml和json等；</li>
<li>制作网络通信协议；</li>
</ul>
<h3 id="一、资源下载："><a href="#一、资源下载：" class="headerlink" title="一、资源下载："></a>一、资源下载：</h3><ul>
<li>github源码地址：<a href="https://github.com/mgravell/protobuf-net" target="_blank" rel="external">protobuf-net</a></li>
<li>google项目源码下载地址（<strong>访问需翻墙</strong>）：<a href="https://code.google.com/p/protobuf-net/" target="_blank" rel="external">protobuf-net</a></li>
</ul>
<a id="more"></a>
<h3 id="二、数据存储："><a href="#二、数据存储：" class="headerlink" title="二、数据存储："></a>二、数据存储：</h3><p>C#语言方式的导表和解析过程，在之前的篇章中已经有详细的阐述：<a href="http://blog.csdn.net/linshuhe1/article/details/52062969" target="_blank" rel="external">Unity —— protobuf 导excel表格数据</a>，建议在看后续的操作之前先看一下这篇文档，因为后面设计到得一些操作与导表中是一致的，而且在理解了导表过程之后，能够快速地理解协议数据<strong>序列化</strong>和<strong>反序列化</strong>的过程。</p>
<h3 id="三、网络协议："><a href="#三、网络协议：" class="headerlink" title="三、网络协议："></a>三、网络协议：</h3><h4 id="1-设计思想："><a href="#1-设计思想：" class="headerlink" title="1.设计思想："></a>1.设计思想：</h4><p>有两个必要的数据：<strong>协议号</strong>和<strong>协议类型</strong>，将这两个数据分别存储起来</p>
<ul>
<li>当客户端向服务器发送数据时，会根据协议类型加上协议号，然后使用protobuf序列化之后再发送给服务器；</li>
<li>当服务器发送数据给客户端时，根据协议号，用protobuf根据协议类型反序列化数据，并调用相应回调方法。</li>
</ul>
<p>由于数据在传输过程中，都是以数据流的形式存在的，而进行解析时无法单从protobuf数据中得知使用哪个解析类进行数据反序列化，这就要求我们在传输protobuf数据的同时，携带一个协议号，通过协议号和协议类型（解析类）之间的对应关系来确定进行数据反序列化的解析类。<br><img src="http://img.blog.csdn.net/20160824100320406" alt=""><br>此处协议号的作用就是用来确定用于解析数据的解析类，所以也可能称之为<strong>协议类型名</strong>，可以是<code>string</code>和<code>int</code>类型的数据。</p>
<h4 id="2-特点分析："><a href="#2-特点分析：" class="headerlink" title="2.特点分析："></a>2.特点分析：</h4><p>使用protobuf作为网络通信的数据载体，具有几个优点：</p>
<ul>
<li>通过序列化之后<strong>数据量比较小</strong>；</li>
<li>而且<strong>以key-value的方式存储数据</strong>，这对于消息的版本兼容比较强；</li>
<li>此外，由于protobuf提供的多语言支持，所以使用protobuf作为数据载体定制的网络协议<strong>具有很强的跨语言特性</strong>。</li>
</ul>
<h3 id="四、样例实现："><a href="#四、样例实现：" class="headerlink" title="四、样例实现："></a>四、样例实现：</h3><h4 id="1-协议定义："><a href="#1-协议定义：" class="headerlink" title="1.协议定义："></a>1.协议定义：</h4><p>在之前导表的时候，我们得到了.proto的解析类，这是protobuf提供的一种特殊的脚本，具有格式简单、可读性强和方便拓展的特点，所以接下来我们就是<strong>使用proto脚本来定义我们的协议</strong>。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 物品  </div><div class="line">message Item  </div><div class="line">&#123;  </div><div class="line">    required int32 Type     = 1;    //游戏物品大类  </div><div class="line">    optional int32 SubType  = 2;    //游戏物品小类  </div><div class="line">    required int32 num      = 3;    //游戏物品数量  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">// 物品列表  </div><div class="line">message ItemList  </div><div class="line">&#123;  </div><div class="line">    repeated Item item  = 1;    //物品列表  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述例子中，Item相当于定义了一个数据结构或者是类，而ItemList是一个列表，列表中的每个元素都是一个Item对象。注意结构关键词：</p>
<ul>
<li><code>required</code>：必有的属性</li>
<li><code>optional</code>：可选属性</li>
<li><code>repeated</code>：数组</li>
</ul>
<p>其实protobuf在这里只是提供了一个数据载体，通过在.proto中定义数据结构之后，需要使用与导表时一样的操作，步骤为：</p>
<ul>
<li>使用<strong>protoc.exe</strong>将.proto文件转化为.protodesc中间格式；</li>
<li>使用<strong>protogen.exe</strong>将中间格式为.protodesc生成指定的高级语言类，我们在Unity中使用的是C#,所以结果是.cs类</li>
</ul>
<p>经过上述步骤之后，我们得到了协议类型对应的C#反序列化类，当我们收到服务器数据时，<strong>根据协议号找到协议类型</strong>，从而使用对应的反序列化的类对数据进行反序列化，得到最终的服务器数据内容。</p>
<p>在这里，我们以登录为例，首先要清楚登录需要几个数据，正常情况下至少包含两个数据，即账号和密码，都是字符串类型，即定义cs_login.proto协议脚本，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package cs;  </div><div class="line">  </div><div class="line">message CSLoginInfo  </div><div class="line">&#123;  </div><div class="line">    required string UserName = 1;//账号  </div><div class="line">    required string Password = 2;//密码  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">//发送登录请求  </div><div class="line">message CSLoginReq  </div><div class="line">&#123;  </div><div class="line">    required CSLoginInfo LoginInfo = 1;   </div><div class="line">&#125;  </div><div class="line">//登录请求回包数据  </div><div class="line">message CSLoginRes  </div><div class="line">&#123;  </div><div class="line">    required uint32 result_code = 1;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>package</code>关键字后面的名称为.proto转为.cs之后的命名空间namespace的值，用message可以定义类，这里定义了一个CSLoginInfo的数据类，该类包含了账号和密码两个字符串类型的属性。然后定义了两个消息结构：</p>
<ul>
<li>CSLoginReq登录请求消息，携带的数据是一个CSLoginInfo类型的对象数据；</li>
<li>CSLoginRes登录请求服务器返回的数据类型，返回结果是一个uint32无符号的整型数据，即结果码。</li>
</ul>
<p>上面定义的是协议类型，除此之外我们还需要为每一个协议类型定义一个协议号，这里可以用一个枚举脚本cs_enum.proto来保存，脚本内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package cs;  </div><div class="line">  </div><div class="line">enum EnmCmdID  </div><div class="line">&#123;  </div><div class="line">    CS_LOGIN_REQ = 10001;//登录请求协议号  </div><div class="line">    CS_LOGIN_RES = 10002;//登录请求回包协议号  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用protoc.exe和protogen.exe将这两个protobuf脚本得到C#类，具体步骤参考导表使用的操作，这里我直接给出自动化导表使用的批处理文件general_all.bat内容，具体文件目录可以根据自己放置情况进行调整：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">::---------------------------------------------------  </div><div class="line">::第二步：把proto翻译成protodesc  </div><div class="line">::---------------------------------------------------  </div><div class="line">call proto2cs\protoc protos\cs_login.proto --descriptor_set_out=cs_login.protodesc  </div><div class="line">call proto2cs\protoc protos\cs_enum.proto --descriptor_set_out=cs_enum.protodesc  </div><div class="line">::---------------------------------------------------  </div><div class="line">::第二步：把protodesc翻译成cs  </div><div class="line">::---------------------------------------------------  </div><div class="line">call proto2cs\ProtoGen\protogen -i:cs_login.protodesc -o:cs_login.cs  </div><div class="line">call proto2cs\ProtoGen\protogen -i:cs_enum.protodesc -o:cs_enum.cs  </div><div class="line">::---------------------------------------------------  </div><div class="line">::第二步：把protodesc文件删除  </div><div class="line">::---------------------------------------------------  </div><div class="line">del *.protodesc  </div><div class="line">  </div><div class="line">pause</div></pre></td></tr></table></figure></p>
<p>转换结束后，我们的得到了两个.cs文件分别是：cs_enum.cs和cs_login.cs，将其放入到我们的Unity项目中，以便于接下来序列化和反序列化数据的使用。</p>
<h4 id="2-协议数据构建："><a href="#2-协议数据构建：" class="headerlink" title="2.协议数据构建："></a>2.协议数据构建：</h4><p>直接在项目代码中通过<code>using cs</code>引入协议解析类的命名空间，然后创建消息对象，并对对象的属性进行赋值，即可得到协议数据对象，例如登录请求对象的创建如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CSLoginInfo mLoginInfo = new CSLoginInfo();  </div><div class="line">mLoginInfo.UserName = &quot;linshuhe&quot;;  </div><div class="line">mLoginInfo.Password = &quot;123456&quot;;  </div><div class="line">CSLoginReq mReq = new CSLoginReq();  </div><div class="line">mReq.LoginInfo = mLoginInfo;</div></pre></td></tr></table></figure></p>
<p>从上述代码，可以得到登录请求对象mReq，里面包含了一个CSLoginInfo对象mLoginInfo，再次枚举对象中找到与此协议类型对应的协议号，即：<code>EnmCmdID.CS_LOGIN_REQ</code></p>
<h4 id="3-数据的序列化和反序列化："><a href="#3-数据的序列化和反序列化：" class="headerlink" title="3.数据的序列化和反序列化："></a>3.数据的序列化和反序列化：</h4><p>数据发送的时候必须以数据流的形式进行，所以这里我们需要考虑如何<strong>将要发送的protobuf对象数据进行序列化，转化为byte[]字节数组</strong>，这就需要借助ProtoBuf库为我们提供的<code>Serializer</code>类的<code>Serialize</code>方法来完成，而反序列化则需借助<code>Deserialize</code>方法，将这两个方法封装到PackCodec类中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">using UnityEngine;  </div><div class="line">using System.Collections;  </div><div class="line">using System.IO;  </div><div class="line">using System;  </div><div class="line">using ProtoBuf;  </div><div class="line">  </div><div class="line">/// &lt;summary&gt;  </div><div class="line">/// 网络协议数据打包和解包类  </div><div class="line">/// &lt;/summary&gt;  </div><div class="line">public class PackCodec&#123;  </div><div class="line">    /// &lt;summary&gt;  </div><div class="line">    /// 序列化  </div><div class="line">    /// &lt;/summary&gt;  </div><div class="line">    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;  </div><div class="line">    /// &lt;param name=&quot;msg&quot;&gt;&lt;/param&gt;  </div><div class="line">    /// &lt;returns&gt;&lt;/returns&gt;  </div><div class="line">    static public byte[] Serialize&lt;T&gt;(T msg)  </div><div class="line">    &#123;  </div><div class="line">        byte[] result = null;  </div><div class="line">        if (msg != null)  </div><div class="line">        &#123;  </div><div class="line">            using (var stream = new MemoryStream())  </div><div class="line">            &#123;  </div><div class="line">                Serializer.Serialize&lt;T&gt;(stream, msg);  </div><div class="line">                result = stream.ToArray();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /// &lt;summary&gt;  </div><div class="line">    /// 反序列化  </div><div class="line">    /// &lt;/summary&gt;  </div><div class="line">    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;  </div><div class="line">    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class="line">    /// &lt;returns&gt;&lt;/returns&gt;  </div><div class="line">    static public T Deserialize&lt;T&gt;(byte[] message)  </div><div class="line">    &#123;  </div><div class="line">        T result = default(T);  </div><div class="line">        if (message != null)  </div><div class="line">        &#123;  </div><div class="line">            using (var stream = new MemoryStream(message))  </div><div class="line">            &#123;  </div><div class="line">                result = Serializer.Deserialize&lt;T&gt;(stream);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用方法很简单，直接传入一个数据对象即可得到字节数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">byte[] buf = PackCodec.Serialize(mReq);</div></pre></td></tr></table></figure></p>
<p>为了检验打包和解包是否匹配，我们可以直接做一次本地测试：将打包后的数据直接解包，看看数据是否与原来的一致：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">using UnityEngine;  </div><div class="line">using System.Collections;  </div><div class="line">using System;  </div><div class="line">using cs;  </div><div class="line">using ProtoBuf;  </div><div class="line">using System.IO;  </div><div class="line">  </div><div class="line">public class TestProtoNet : MonoBehaviour &#123;  </div><div class="line">  </div><div class="line">    // Use this for initialization  </div><div class="line">    void Start () &#123;  </div><div class="line">        CSLoginInfo mLoginInfo = new CSLoginInfo();  </div><div class="line">        mLoginInfo.UserName = &quot;linshuhe&quot;;  </div><div class="line">        mLoginInfo.Password = &quot;123456&quot;;  </div><div class="line">        CSLoginReq mReq = new CSLoginReq();  </div><div class="line">        mReq.LoginInfo = mLoginInfo;  </div><div class="line">  </div><div class="line">        byte[] pbdata = PackCodec.Serialize(mReq);  </div><div class="line">        CSLoginReq pReq = PackCodec.Deserialize&lt;CSLoginReq&gt;(pbdata);  </div><div class="line">        Debug.Log(&quot;UserName = &quot; + pReq.LoginInfo.UserName + &quot;, Password = &quot; + pReq.LoginInfo.Password);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    // Update is called once per frame  </div><div class="line">    void Update () &#123;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line">``` </div><div class="line">将此脚本绑到场景中的相机上，运行得到以下结果，则说明打包和解包完全匹配：</div><div class="line">![](http://img.blog.csdn.net/20160825100033496)    </div><div class="line"></div><div class="line">#### 4.数据发送和接收：</div><div class="line">这里我们使用的网络通信方式是Socket的强联网方式，关于如何在Unity中使用Socket进行通信，可以参考我之前的文章：[Unity —— Socket通信(C#)](http://blog.csdn.net/linshuhe1/article/details/51386559)，Unity客户端需要复制此项目的**ClientSocket.cs**和**ByteBuffer.cs**两个类到当前项目中。</div><div class="line"></div><div class="line">此外，服务器可以参照之前的方式搭建，唯一不同的是RecieveMessage(object clientSocket)方法解析数据的过程需要进行修改，因为需要使用protobuf-net.dll进行数据解包，所以需要参考客户端的做法，把protobuf-net.dll复制到服务器项目中的Protobuf_net目录下：  </div><div class="line">![](http://img.blog.csdn.net/20160825175754877)</div><div class="line">假如由于直接使用源码而不用.dll会出现不安全保存，需要在Visual Studio中设置允许不安全代码，具体步骤为：在“解决方案”中选中工程，右键“数据”，选择“生成”页签，勾选“允许不安全代码”：</div><div class="line">![](http://img.blog.csdn.net/20160825180841975)    </div><div class="line">当然，解析数据所用的解析类和协议号两个脚本cs_login.cs和cs_enum.cs也应该添加到服务器项目中，保证客户端和服务器一直，此外PackCodec.cs也需要添加到服务器代码中但是要把其中的using UnityEngine给去掉防止报错，最终服务器目录结构如下：</div><div class="line">![](http://img.blog.csdn.net/20160825191847662)</div><div class="line"></div><div class="line">#### 5.完整协议数据的封装：</div><div class="line">从之前说过的设计思路分析，我们在发送数据的时候除了要发送关键的protobuf数据之外，还需要带上两个附件的数据：协议头（用于进行通信检验）和协议号（用于确定解析类）。假设我们的是：</div><div class="line"></div><div class="line">- **协议头**：用于表示后面数据的长度，一个short类型的数据：</div><div class="line">```C#</div><div class="line">/// &lt;summary&gt;  </div><div class="line">/// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class="line">/// &lt;/summary&gt;  </div><div class="line">/// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class="line">/// &lt;returns&gt;&lt;/returns&gt;  </div><div class="line">private static byte[] WriteMessage(byte[] message)  </div><div class="line">&#123;  </div><div class="line">    MemoryStream ms = null;  </div><div class="line">    using (ms = new MemoryStream())  </div><div class="line">    &#123;  </div><div class="line">        ms.Position = 0;  </div><div class="line">        BinaryWriter writer = new BinaryWriter(ms);  </div><div class="line">        ushort msglen = (ushort)message.Length;  </div><div class="line">        writer.Write(msglen);  </div><div class="line">        writer.Write(message);  </div><div class="line">        writer.Flush();  </div><div class="line">        return ms.ToArray();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>协议号</strong>：用于对应解析类，这里我们使用的是int类型的数据：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private byte[] CreateData(int typeId,IExtensible pbuf)  </div><div class="line">  </div><div class="line">byte[] pbdata = PackCodec.Serialize(pbuf);  </div><div class="line">ByteBuffer buff = new ByteBuffer();  </div><div class="line">buff.WriteInt(typeId);  </div><div class="line">buff.WriteBytes(pbdata);  </div><div class="line">return buff.ToBytes();</div></pre></td></tr></table></figure>
<p>客户端发送登录数据时测试脚本TestProtoNet如下，测试需要将此脚本绑定到当前场景的相机上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">using UnityEngine;  </div><div class="line">using System.Collections;  </div><div class="line">using System;  </div><div class="line">using cs;  </div><div class="line">using Net;  </div><div class="line">using ProtoBuf;  </div><div class="line">using System.IO;  </div><div class="line">  </div><div class="line">public class TestProtoNet : MonoBehaviour &#123;  </div><div class="line">  </div><div class="line">    // Use this for initialization  </div><div class="line">    void Start () &#123;  </div><div class="line">  </div><div class="line">  </div><div class="line">        CSLoginInfo mLoginInfo = new CSLoginInfo();  </div><div class="line">        mLoginInfo.UserName = &quot;linshuhe&quot;;  </div><div class="line">        mLoginInfo.Password = &quot;123456&quot;;  </div><div class="line">        CSLoginReq mReq = new CSLoginReq();  </div><div class="line">        mReq.LoginInfo = mLoginInfo;  </div><div class="line">  </div><div class="line">        byte[] data = CreateData((int)EnmCmdID.CS_LOGIN_REQ, mReq);  </div><div class="line">        ClientSocket mSocket = new ClientSocket();  </div><div class="line">        mSocket.ConnectServer(&quot;127.0.0.1&quot;, 8088);  </div><div class="line">        mSocket.SendMessage(data);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    private byte[] CreateData(int typeId,IExtensible pbuf)  </div><div class="line">    &#123;  </div><div class="line">        byte[] pbdata = PackCodec.Serialize(pbuf);  </div><div class="line">        ByteBuffer buff = new ByteBuffer();  </div><div class="line">        buff.WriteInt(typeId);  </div><div class="line">        buff.WriteBytes(pbdata);  </div><div class="line">        return WriteMessage(buff.ToBytes());  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /// &lt;summary&gt;  </div><div class="line">    /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class="line">    /// &lt;/summary&gt;  </div><div class="line">    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class="line">    /// &lt;returns&gt;&lt;/returns&gt;  </div><div class="line">    private static byte[] WriteMessage(byte[] message)  </div><div class="line">    &#123;  </div><div class="line">        MemoryStream ms = null;  </div><div class="line">        using (ms = new MemoryStream())  </div><div class="line">        &#123;  </div><div class="line">            ms.Position = 0;  </div><div class="line">            BinaryWriter writer = new BinaryWriter(ms);  </div><div class="line">            ushort msglen = (ushort)message.Length;  </div><div class="line">            writer.Write(msglen);  </div><div class="line">            writer.Write(message);  </div><div class="line">            writer.Flush();  </div><div class="line">            return ms.ToArray();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    // Update is called once per frame  </div><div class="line">    void Update () &#123;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line">``` </div><div class="line"></div><div class="line">服务器接受数据解包过程参考打包数据的格式，在RecieveMessage(object clientSocket)中，解析数据的核心代码如下：</div><div class="line"></div><div class="line">```C#</div><div class="line">ByteBuffer buff = new ByteBuffer(result);  </div><div class="line">int datalength = buff.ReadShort();  </div><div class="line">int typeId = buff.ReadInt();  </div><div class="line">byte[] pbdata = buff.ReadBytes();  </div><div class="line">//通过协议号判断选择的解析类  </div><div class="line">if(typeId == (int)EnmCmdID.CS_LOGIN_REQ)  </div><div class="line">&#123;  </div><div class="line">        CSLoginReq clientReq = PackCodec.Deserialize&lt;CSLoginReq&gt;(pbdata);  </div><div class="line">        string user_name = clientReq.LoginInfo.UserName;  </div><div class="line">        string pass_word = clientReq.LoginInfo.Password;  </div><div class="line">        Console.WriteLine(&quot;数据内容：UserName=&#123;0&#125;,Password=&#123;1&#125;&quot;, user_name, pass_word);  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面通过typeId来找到匹配的数据解析类，协议少的时候可以使用这种简单的使用if语句分支判断来实现，但是假如协议类型多了，则需要进一步封装查找方法，常用的方法有：定义一个Dictionary<int,type>字典来存放协议号（int）和协议类型（Type）的对应关系。</int,type></p>
<h4 id="6-运行结果："><a href="#6-运行结果：" class="headerlink" title="6.运行结果："></a>6.运行结果：</h4><p>启动服务器，然后运行Unity中的客户端，得到正确的结果应该如下：<br><img src="http://img.blog.csdn.net/20160825192659728" alt=""><br>项目服务器和客户端的完整代码可以前往此处下载：<a href="http://download.csdn.net/detail/linshuhe1/9613076" target="_blank" rel="external">protobuf-net网络协议的定制</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity3D —— Socket通信]]></title>
      <url>http://yoursite.com/2016/09/19/Unity3D-Socket%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>在开始编写代码之前，我们首先需要明确：联网方式、联网步骤、数据收发以及协议数据格式</p>
<p>当然在设计时也应该减低代码的耦合性，尽量使得网络层可以在其他地方进行复用，这就需要我们进行接口式的开发。我们这里使用的通信模式是Socket强连接的通信方式，并且使用C#作为编程语言，其实与.NET的Socket通信是一致的。</p>
<h3 id="一、设计思想："><a href="#一、设计思想：" class="headerlink" title="一、设计思想："></a>一、设计思想：</h3><p>为了方便测试，我直接使用C#写的一个控制台应用，作为服务器，等待客户端的连接，然后使用Unity建立Socket客户端去连接服务器，进行简单的数据通信。这么设计的原因是都基于.net进行开发，也方便理解。</p>
<a id="more"></a>
<h3 id="二、实现步骤："><a href="#二、实现步骤：" class="headerlink" title="二、实现步骤："></a>二、实现步骤：</h3><p>对于网络通信有所了解的都应该知道，数据在网络传输的格式必须以字节流的形式进行，那么免不了要对字节流进行写入和读出操作，为了方便后面的操作，我们有必要封装一个读写字节流的操作类，在这里我定义了一个字节流的操作类ByteBuffer类，用于将各个类型数据写入流中，也可从字节流中读取各种类型的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">using System.IO;  </div><div class="line">using System.Text;  </div><div class="line">using System;  </div><div class="line">  </div><div class="line">namespace Net &#123;  </div><div class="line">    public class ByteBuffer &#123;  </div><div class="line">        MemoryStream stream = null;  </div><div class="line">        BinaryWriter writer = null;  </div><div class="line">        BinaryReader reader = null;  </div><div class="line">  </div><div class="line">        public ByteBuffer() &#123;  </div><div class="line">            stream = new MemoryStream();  </div><div class="line">            writer = new BinaryWriter(stream);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public ByteBuffer(byte[] data) &#123;  </div><div class="line">            if (data != null) &#123;  </div><div class="line">                stream = new MemoryStream(data);  </div><div class="line">                reader = new BinaryReader(stream);  </div><div class="line">            &#125; else &#123;  </div><div class="line">                stream = new MemoryStream();  </div><div class="line">                writer = new BinaryWriter(stream);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public void Close() &#123;  </div><div class="line">            if (writer != null) writer.Close();  </div><div class="line">            if (reader != null) reader.Close();  </div><div class="line">  </div><div class="line">            stream.Close();  </div><div class="line">            writer = null;  </div><div class="line">            reader = null;  </div><div class="line">            stream = null;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public void WriteByte(byte v) &#123;  </div><div class="line">            writer.Write(v);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public void WriteInt(int v) &#123;  </div><div class="line">            writer.Write((int)v);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public void WriteShort(ushort v) &#123;  </div><div class="line">            writer.Write((ushort)v);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public void WriteLong(long v) &#123;  </div><div class="line">            writer.Write((long)v);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public void WriteFloat(float v) &#123;  </div><div class="line">            byte[] temp = BitConverter.GetBytes(v);  </div><div class="line">            Array.Reverse(temp);  </div><div class="line">            writer.Write(BitConverter.ToSingle(temp, 0));  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public void WriteDouble(double v) &#123;  </div><div class="line">            byte[] temp = BitConverter.GetBytes(v);  </div><div class="line">            Array.Reverse(temp);  </div><div class="line">            writer.Write(BitConverter.ToDouble(temp, 0));  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public void WriteString(string v) &#123;  </div><div class="line">            byte[] bytes = Encoding.UTF8.GetBytes(v);  </div><div class="line">            writer.Write((ushort)bytes.Length);  </div><div class="line">            writer.Write(bytes);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public void WriteBytes(byte[] v) &#123;  </div><div class="line">            writer.Write((int)v.Length);  </div><div class="line">            writer.Write(v);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public byte ReadByte() &#123;  </div><div class="line">            return reader.ReadByte();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public int ReadInt() &#123;  </div><div class="line">            return (int)reader.ReadInt32();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public ushort ReadShort() &#123;  </div><div class="line">            return (ushort)reader.ReadInt16();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public long ReadLong() &#123;  </div><div class="line">            return (long)reader.ReadInt64();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public float ReadFloat() &#123;  </div><div class="line">            byte[] temp = BitConverter.GetBytes(reader.ReadSingle());  </div><div class="line">            Array.Reverse(temp);  </div><div class="line">            return BitConverter.ToSingle(temp, 0);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public double ReadDouble() &#123;  </div><div class="line">            byte[] temp = BitConverter.GetBytes(reader.ReadDouble());  </div><div class="line">            Array.Reverse(temp);  </div><div class="line">            return BitConverter.ToDouble(temp, 0);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public string ReadString() &#123;  </div><div class="line">            ushort len = ReadShort();  </div><div class="line">            byte[] buffer = new byte[len];  </div><div class="line">            buffer = reader.ReadBytes(len);  </div><div class="line">            return Encoding.UTF8.GetString(buffer);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public byte[] ReadBytes() &#123;  </div><div class="line">            int len = ReadInt();  </div><div class="line">            return reader.ReadBytes(len);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public byte[] ToBytes() &#123;  </div><div class="line">            writer.Flush();  </div><div class="line">            return stream.ToArray();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public void Flush() &#123;  </div><div class="line">            writer.Flush();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用此操作类进行读写数据的操作范例如下：</p>
<ul>
<li><p>读取数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//result是字节数组byte[],从中读取两个int类型的数据  </div><div class="line"> ByteBuffer buff = new ByteBuffer(result);  </div><div class="line"> int len = buff.ReadShort();  </div><div class="line"> int protoId = buff.ReadShort();</div></pre></td></tr></table></figure>
</li>
<li><p>写入数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//result是字节数组byte[],从写入两个不同类型的数据  </div><div class="line">ByteBuffer buff = new ByteBuffer();  </div><div class="line">int protoId = ProtoDic.GetProtoIdByProtoType(0);  </div><div class="line">buff.WriteShort((ushort)protoId);  </div><div class="line">buff.WriteBytes(ms.ToArray());  </div><div class="line">byte[] result = buff.ToBytes();</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-服务器创建："><a href="#1-服务器创建：" class="headerlink" title="1.服务器创建："></a>1.服务器创建：</h4><p>在VS中新建一个C#控制台应用，新建项目完成后将上面定义的ByteBuffer.cs类导入工程中，然后开始在入口类Program中开始创建Socket服务器的逻辑。</p>
<ul>
<li>先引入必要的命名空间：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">using System.Net;  </div><div class="line">using System.Net.Sockets;  </div><div class="line">using System.Threading;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>基本的步骤如下：</p>
<ul>
<li>创建一个服务器Socket对象，并绑定服务器IP地址和端口号；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private const int port = 8088;  </div><div class="line">private static string IpStr = &quot;127.0.0.1&quot;;  </div><div class="line">private static Socket serverSocket;  </div><div class="line">  </div><div class="line">static void Main(string[] args)  </div><div class="line">&#123;  </div><div class="line">    IPAddress ip = IPAddress.Parse(IpStr);  </div><div class="line">    IPEndPoint ip_end_point = new IPEndPoint(ip, port);  </div><div class="line">    //创建服务器Socket对象，并设置相关属性  </div><div class="line">    serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  </div><div class="line">    //绑定ip和端口  </div><div class="line">    serverSocket.Bind(ip_end_point);  </div><div class="line">    //设置最长的连接请求队列长度  </div><div class="line">    serverSocket.Listen(10);  </div><div class="line">    Console.WriteLine(&quot;启动监听&#123;0&#125;成功&quot;, serverSocket.LocalEndPoint.ToString());  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>完成上述代码之后，已经能正常启动一个服务器Socket，但是还没有处理连接监听逻辑和数据接收，所以运行应用会出现一闪就关掉的情况。</p>
<ul>
<li><p>启动一个线程，并在线程中监听客户端的连接，为每个连接创建一个Socket对象；</p>
</li>
<li><p>创建接受数据和发送数据的方法，完整的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">using System;  </div><div class="line">using System.Collections.Generic;  </div><div class="line">using System.Linq;  </div><div class="line">using System.Net.Sockets;  </div><div class="line">using System.Text;  </div><div class="line">using System.Threading.Tasks;  </div><div class="line">using System.Net;  </div><div class="line">using System.Threading;  </div><div class="line">using Net;  </div><div class="line">using System.IO;  </div><div class="line">  </div><div class="line">namespace ConsoleApplication1  </div><div class="line">&#123;  </div><div class="line">    class Program  </div><div class="line">    &#123;  </div><div class="line">        private static byte[] result = new byte[1024];  </div><div class="line">        private const int port = 8088;  </div><div class="line">        private static string IpStr = &quot;127.0.0.1&quot;;  </div><div class="line">        private static Socket serverSocket;  </div><div class="line">  </div><div class="line">        static void Main(string[] args)  </div><div class="line">        &#123;  </div><div class="line">            IPAddress ip = IPAddress.Parse(IpStr);  </div><div class="line">            IPEndPoint ip_end_point = new IPEndPoint(ip, port);  </div><div class="line">            //创建服务器Socket对象，并设置相关属性  </div><div class="line">            serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  </div><div class="line">            //绑定ip和端口  </div><div class="line">            serverSocket.Bind(ip_end_point);  </div><div class="line">            //设置最长的连接请求队列长度  </div><div class="line">            serverSocket.Listen(10);  </div><div class="line">            Console.WriteLine(&quot;启动监听&#123;0&#125;成功&quot;, serverSocket.LocalEndPoint.ToString());  </div><div class="line">            //在新线程中监听客户端的连接  </div><div class="line">            Thread thread = new Thread(ClientConnectListen);  </div><div class="line">            thread.Start();  </div><div class="line">            Console.ReadLine();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        /// &lt;summary&gt;  </div><div class="line">        /// 客户端连接请求监听  </div><div class="line">        /// &lt;/summary&gt;  </div><div class="line">        private static void ClientConnectListen()  </div><div class="line">        &#123;  </div><div class="line">            while (true)  </div><div class="line">            &#123;  </div><div class="line">                //为新的客户端连接创建一个Socket对象  </div><div class="line">                Socket clientSocket = serverSocket.Accept();  </div><div class="line">                Console.WriteLine(&quot;客户端&#123;0&#125;成功连接&quot;, clientSocket.RemoteEndPoint.ToString());  </div><div class="line">                //向连接的客户端发送连接成功的数据  </div><div class="line">                ByteBuffer buffer = new ByteBuffer();  </div><div class="line">                buffer.WriteString(&quot;Connected Server&quot;);  </div><div class="line">                clientSocket.Send(WriteMessage(buffer.ToBytes()));  </div><div class="line">                //每个客户端连接创建一个线程来接受该客户端发送的消息  </div><div class="line">                Thread thread = new Thread(RecieveMessage);  </div><div class="line">                thread.Start(clientSocket);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        /// &lt;summary&gt;  </div><div class="line">        /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class="line">        /// &lt;/summary&gt;  </div><div class="line">        /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class="line">        /// &lt;returns&gt;&lt;/returns&gt;  </div><div class="line">        private static byte[] WriteMessage(byte[] message)  </div><div class="line">        &#123;  </div><div class="line">            MemoryStream ms = null;  </div><div class="line">            using (ms = new MemoryStream())  </div><div class="line">            &#123;  </div><div class="line">                ms.Position = 0;  </div><div class="line">                BinaryWriter writer = new BinaryWriter(ms);  </div><div class="line">                ushort msglen = (ushort)message.Length;  </div><div class="line">                writer.Write(msglen);  </div><div class="line">                writer.Write(message);  </div><div class="line">                writer.Flush();  </div><div class="line">                return ms.ToArray();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        /// &lt;summary&gt;  </div><div class="line">        /// 接收指定客户端Socket的消息  </div><div class="line">        /// &lt;/summary&gt;  </div><div class="line">        /// &lt;param name=&quot;clientSocket&quot;&gt;&lt;/param&gt;  </div><div class="line">        private static void RecieveMessage(object clientSocket)  </div><div class="line">        &#123;  </div><div class="line">            Socket mClientSocket = (Socket)clientSocket;  </div><div class="line">            while (true)  </div><div class="line">            &#123;  </div><div class="line">                try  </div><div class="line">                &#123;  </div><div class="line">                    int receiveNumber = mClientSocket.Receive(result);  </div><div class="line">                    Console.WriteLine(&quot;接收客户端&#123;0&#125;消息， 长度为&#123;1&#125;&quot;, mClientSocket.RemoteEndPoint.ToString(), receiveNumber);  </div><div class="line">                    ByteBuffer buff = new ByteBuffer(result);  </div><div class="line">                    //数据长度  </div><div class="line">                    int len = buff.ReadShort();  </div><div class="line">                    //数据内容  </div><div class="line">                    string data = buff.ReadString();  </div><div class="line">                    Console.WriteLine(&quot;数据内容：&#123;0&#125;&quot;, data);  </div><div class="line">                &#125;  </div><div class="line">                catch (Exception ex)  </div><div class="line">                &#123;  </div><div class="line">                    Console.WriteLine(ex.Message);  </div><div class="line">                    mClientSocket.Shutdown(SocketShutdown.Both);  </div><div class="line">                    mClientSocket.Close();  </div><div class="line">                    break;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-客户端创建："><a href="#2-客户端创建：" class="headerlink" title="2.客户端创建："></a>2.客户端创建：</h4><p>客户端连接服务器的逻辑相对简单一些，跟服务器一样，先把ByteBuffer类导入到工程中，基本步骤如下：</p>
<ul>
<li>创建一个Socket对象，这个对象在客户端是唯一的，可以理解为单例模式；</li>
<li>使用上面创建Socket连接指定服务器IP和端口号；</li>
<li>接收服务器数据和发送数据给服务器。</li>
</ul>
<p>先创建一个ClientSocket类用于管理Socket的一些方法：连接服务器、接受数据和发送数据等：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">using UnityEngine;  </div><div class="line">using System.Collections;  </div><div class="line">using System.Net;  </div><div class="line">using System.Net.Sockets;  </div><div class="line">using System.IO;  </div><div class="line">  </div><div class="line">namespace Net  </div><div class="line">&#123;  </div><div class="line">    public class ClientSocket  </div><div class="line">    &#123;  </div><div class="line">        private static byte[] result = new byte[1024];  </div><div class="line">        private static Socket clientSocket;  </div><div class="line">        //是否已连接的标识  </div><div class="line">        public bool IsConnected = false;  </div><div class="line">  </div><div class="line">        public ClientSocket()&#123;  </div><div class="line">            clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        /// &lt;summary&gt;  </div><div class="line">        /// 连接指定IP和端口的服务器  </div><div class="line">        /// &lt;/summary&gt;  </div><div class="line">        /// &lt;param name=&quot;ip&quot;&gt;&lt;/param&gt;  </div><div class="line">        /// &lt;param name=&quot;port&quot;&gt;&lt;/param&gt;  </div><div class="line">        public void ConnectServer(string ip,int port)  </div><div class="line">        &#123;  </div><div class="line">            IPAddress mIp = IPAddress.Parse(ip);  </div><div class="line">            IPEndPoint ip_end_point = new IPEndPoint(mIp, port);  </div><div class="line">  </div><div class="line">            try &#123;  </div><div class="line">                clientSocket.Connect(ip_end_point);  </div><div class="line">                IsConnected = true;  </div><div class="line">                Debug.Log(&quot;连接服务器成功&quot;);  </div><div class="line">            &#125;  </div><div class="line">            catch  </div><div class="line">            &#123;  </div><div class="line">                IsConnected = false;  </div><div class="line">                Debug.Log(&quot;连接服务器失败&quot;);  </div><div class="line">                return;  </div><div class="line">            &#125;  </div><div class="line">            //服务器下发数据长度  </div><div class="line">            int receiveLength = clientSocket.Receive(result);  </div><div class="line">            ByteBuffer buffer = new ByteBuffer(result);  </div><div class="line">            int len = buffer.ReadShort();  </div><div class="line">            string data = buffer.ReadString();  </div><div class="line">            Debug.Log(&quot;服务器返回数据：&quot; + data);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        /// &lt;summary&gt;  </div><div class="line">        /// 发送数据给服务器  </div><div class="line">        /// &lt;/summary&gt;  </div><div class="line">        public void SendMessage(string data)  </div><div class="line">        &#123;  </div><div class="line">            if (IsConnected == false)  </div><div class="line">                return;  </div><div class="line">            try  </div><div class="line">            &#123;  </div><div class="line">                ByteBuffer buffer = new ByteBuffer();  </div><div class="line">                buffer.WriteString(data);  </div><div class="line">                clientSocket.Send(WriteMessage(buffer.ToBytes()));  </div><div class="line">            &#125;  </div><div class="line">            catch  </div><div class="line">            &#123;  </div><div class="line">                IsConnected = false;  </div><div class="line">                clientSocket.Shutdown(SocketShutdown.Both);  </div><div class="line">                clientSocket.Close();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        /// &lt;summary&gt;  </div><div class="line">        /// 数据转换，网络发送需要两部分数据，一是数据长度，二是主体数据  </div><div class="line">        /// &lt;/summary&gt;  </div><div class="line">        /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;  </div><div class="line">        /// &lt;returns&gt;&lt;/returns&gt;  </div><div class="line">        private static byte[] WriteMessage(byte[] message)  </div><div class="line">        &#123;  </div><div class="line">            MemoryStream ms = null;  </div><div class="line">            using (ms = new MemoryStream())  </div><div class="line">            &#123;  </div><div class="line">                ms.Position = 0;  </div><div class="line">                BinaryWriter writer = new BinaryWriter(ms);  </div><div class="line">                ushort msglen = (ushort)message.Length;  </div><div class="line">                writer.Write(msglen);  </div><div class="line">                writer.Write(message);  </div><div class="line">                writer.Flush();  </div><div class="line">                return ms.ToArray();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="三、样例测试："><a href="#三、样例测试：" class="headerlink" title="三、样例测试："></a>三、样例测试：</h3><h4 id="1-客户端测试："><a href="#1-客户端测试：" class="headerlink" title="1.客户端测试："></a>1.客户端测试：</h4><p>在Unity中写一个测试脚本TestSocket.cs，并将此脚本绑到当前场景的相机上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">using UnityEngine;  </div><div class="line">using System.Collections;  </div><div class="line">using Net;  </div><div class="line">  </div><div class="line">public class TestSocket : MonoBehaviour &#123;  </div><div class="line">  </div><div class="line">    // Use this for initialization  </div><div class="line">    void Start () &#123;  </div><div class="line">        ClientSocket mSocket = new ClientSocket();  </div><div class="line">        mSocket.ConnectServer(&quot;127.0.0.1&quot;, 8088);  </div><div class="line">        mSocket.SendMessage(&quot;服务器傻逼！&quot;);  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    // Update is called once per frame  </div><div class="line">    void Update () &#123;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-启动服务器："><a href="#2-启动服务器：" class="headerlink" title="2.启动服务器："></a>2.启动服务器：</h4><p>在Visual Studio中点击运行按钮，启动服务器：<br><img src="http://img.blog.csdn.net/20160825164018638" alt=""><br>启动正常的话，会弹出一个窗口如下图所示：<br><img src="http://img.blog.csdn.net/20160825164121342" alt=""></p>
<h4 id="3-开始连接："><a href="#3-开始连接：" class="headerlink" title="3.开始连接："></a>3.开始连接：</h4><p>在Unity中运行当前场景，查看输出日志，假如连接成功，输出如下：<br><img src="http://img.blog.csdn.net/20160825164333224" alt=""><br>查看服务器窗口，发现双向通信都正常：<br><img src="http://img.blog.csdn.net/20160825164551251" alt=""></p>
<h3 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h3><p>这里测试案例其实很简单，协议没有进行如何优化，单纯地发送字符串数据而已，假如针对复杂的数据的话，需要创建完整打包和解包协议数据的机制，而且必要时还需要对数据进行加密操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity3D —— protobuf导excel表格数据]]></title>
      <url>http://yoursite.com/2016/09/18/Unity3D-protobuf%E5%AF%BCexcel%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>之前使用<code>NPOI插件</code>编写的导表工具，其实就是直接将数据进行<strong>序列化</strong>，解析时还需要进行<strong>反序列化</strong>，步骤比较繁复，最近看到Google的一个开源的项目<code>protobuf</code>，不仅可以用于进行excel表格数据的导出，还能直接用于网络通信协议的定制。</p>
<h3 id="一、protobuf简介："><a href="#一、protobuf简介：" class="headerlink" title="一、protobuf简介："></a>一、protobuf简介：</h3><p>protobuf是由google公司发布的一个开源的项目，是一款方便而又通用的数据传输协议。所以我们在Unity中也可以借助protobuf来进行数据存储和网络协议两方面的开发，这里先说说数据存储部分的操作，也就是：<strong>将.xls表格数据通过protobuf进行序列化，并在Unity中使用。</strong></p>
<a id="more"></a>
<h4 id="1-下载资源："><a href="#1-下载资源：" class="headerlink" title="1.下载资源："></a>1.下载资源：</h4><ul>
<li><a href="http://blog.csdn.net/linshuhe1/article/details/52056864" target="_blank" rel="external">python2.7安装和配置</a></li>
<li><a href="http://pan.baidu.com/s/1kVk5LhP" target="_blank" rel="external">protobuf-2.5.0.zip</a></li>
<li><a href="https://github.com/mgravell/protobuf-net" target="_blank" rel="external">protobuf-net</a></li>
</ul>
<h4 id="2-流程图："><a href="#2-流程图：" class="headerlink" title="2.流程图："></a>2.流程图：</h4><p><img src="http://img.blog.csdn.net/20160818164221144" alt=""><br>从上图可看出基本的操作步骤：</p>
<ul>
<li>.xls表格文件，先通过<code>xls_deploy_tool.py</code>生成对应的.data文件和.proto文件，其中.data文件就是表格数据序列化后的结果，而.proto文件则是用于生成反序列化时使用的解析类的中间状态；</li>
<li>解析类.proto经过<code>protoc.exe</code>转换成.desc文件，用于后面通过protobuf-net等工具转化为特定的语言，这里我们需要得到的是C#解析类，即.cs类；</li>
<li>在Unity中导入<code>protobuf-net.dll</code>库，在C#代码中调用上述生成的.cs解析类来解析.data中的数据。</li>
</ul>
<h3 id="二、导表环境配置："><a href="#二、导表环境配置：" class="headerlink" title="二、导表环境配置："></a>二、导表环境配置：</h3><h4 id="1-Python相关配置："><a href="#1-Python相关配置：" class="headerlink" title="1.Python相关配置："></a>1.Python相关配置：</h4><p>由于从.xls文件生成.data和.proto，Python需要依赖<code>Proto库</code>和<code>xlrd库</code>，安装配置步骤：</p>
<ul>
<li><p><strong>setuptools</strong>：这是Python的组件安装管理器，需要在安装protobuff组件前进行安装，到<a href="https://pypi.python.org/pypi/setuptools#downloads" target="_blank" rel="external">setuptools官网</a>下载插件的安装包，解压到指定目录，然后使用命令行进入安装包目录，执行指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup.py install；</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Protobuff</strong>：首先，我们将之前下载好的<strong>源码包protobuf-2.5.0.zip</strong>和<strong>编译包protoc-2.5.0-win32.zip</strong>压缩包解压到指定目录，路径最好不要包含中文；</p>
<ul>
<li>这里我解压protobuf-2.5.0.zip到的位置是“E:\Unity_Workplace\protobuf_250”；</li>
<li>然后复制protoc-2.5.0-win32.zip解压得到的<strong>protoc.exe</strong>到protobuf_250\src目录下；</li>
<li>在protobuf-2.5.0\python\google\protobuf下创建一个文件夹命名为<strong>compiler</strong>（安装完成后会在此目录下生成两个文件<strong>init</strong>.py和plugin_pb2.py）；</li>
<li>使用命令行进入到解压后的目录下面的<strong>Python目录</strong>，执行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup.py install；</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>xlrd(xls reader)</strong>：这其实是读取xls表格数据的一个工具插件，到<a href="https://pypi.python.org/pypi/xlrd" target="_blank" rel="external">xlrd官网</a>下载xrld的安装包，解压安装包然后使用命令行进入安装包目录，执行指令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup.py install。</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-导表外部工具："><a href="#2-导表外部工具：" class="headerlink" title="2.导表外部工具："></a>2.导表外部工具：</h4><ul>
<li><p><strong>xls_deploy_tool.py</strong>：这个工具其实是github上的一个开源的符合protobuff标准的根据excel自动生成匹配的PB的定义（<code>.proto文件</code>）并将数据序列化后生成二进制数据或者文本数据（<code>.data文件</code>）的一个工具，github下载地址：<a href="https://github.com/jameyli/tnt/tree/master/python" target="_blank" rel="external">xls_deploy_tool.py</a>。</p>
</li>
<li><p><strong>protoc.exe和protogen.exe</strong>：通过上面的工具，我们得到了两个文件：存储数据的.data文件和用于解析数据的.proto文件，但是我们在真正使用解析类来进行数据文件的解析时，必须是高级语言，当然protobuf-net提供很多种高级语言的支持。就像我们在Unity中我们使用的是C#语言，这需要两个工具来实现，一个是protobuf-2.5.0中的<code>protoc.exe</code>将.proto文件转换为“FileDescriptorSet”中间格式；另一个是使用protobuf-net中的<code>protogen.exe</code>，将中间格式的文件转换为最终状态，即高级语言的解析类.cs文件。</p>
</li>
<li><p>可以到github上下载protobuf-net的源码：<a href="https://github.com/linshuhe/protobuf-net" target="_blank" rel="external">protobuf-net</a>，下载后解压到本地，然后进入到解压后protobuf-net-master\protobuf-net目录下，通过Visual Studio打开protobuf-net.csproj：<br><img src="http://img.blog.csdn.net/20160822105531605" alt=""> <img src="http://img.blog.csdn.net/20160822105539356" alt=""></p>
</li>
<li><p>编译完成后在当前目录下面的bin\Release目录下，生成了编译后的文件，其中我们需要的是protobuf-net.dll：<br><img src="http://img.blog.csdn.net/20160822112150454" alt=""></p>
</li>
<li><p>将protobuf-net.dll复制到protobuf-net-master\ProtoGen目录下，用Visual Studio打开ProtoGen.csproj，参照上面步骤编译ProtoGen项目，得到protobuf-net-master\ProtoGen\bin\Release目录下面的protogen.exe及一些额外的文件，但在真正使用时此目录下面的所有文件都是必须的：<br><img src="http://img.blog.csdn.net/20160822112506834" alt=""></p>
</li>
</ul>
<h3 id="三、样例："><a href="#三、样例：" class="headerlink" title="三、样例："></a>三、样例：</h3><h4 id="1-建立表格-xls："><a href="#1-建立表格-xls：" class="headerlink" title="1.建立表格.xls："></a>1.建立表格.xls：</h4><p>当然使用此工具进行导表的表格需要符合指定的格式，根据xls_deploy_tool.py的备注内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 说明:  </span></div><div class="line"><span class="comment">#   excel 的前四行用于结构定义, 其余则为数据，按第一行区分, 分别解释：  </span></div><div class="line"><span class="comment">#       required 必有属性  </span></div><div class="line"><span class="comment">#       optional 可选属性  </span></div><div class="line"><span class="comment">#           第二行: 属性类型  </span></div><div class="line"><span class="comment">#           第三行：属性名  </span></div><div class="line"><span class="comment">#           第四行：注释  </span></div><div class="line"><span class="comment">#           数据行：属性值  </span></div><div class="line"><span class="comment">#       repeated 表明下一个属性是repeated,即数组  </span></div><div class="line"><span class="comment">#           第二行: repeat的最大次数, excel中会重复列出该属性  </span></div><div class="line"><span class="comment">#           2011-11-29 做了修改 第二行如果是类型定义的话，则表明该列是repeated  </span></div><div class="line"><span class="comment">#           但是目前只支持整形  </span></div><div class="line"><span class="comment">#           第三行：无用  </span></div><div class="line"><span class="comment">#           第四行：注释  </span></div><div class="line"><span class="comment">#           数据行：实际的重复次数  </span></div><div class="line"><span class="comment">#       required_struct 必选结构属性  </span></div><div class="line"><span class="comment">#       optional_struct 可选结构属性  </span></div><div class="line"><span class="comment">#           第二行：结构元素个数  </span></div><div class="line"><span class="comment">#           第三行：结构名  </span></div><div class="line"><span class="comment">#           第四行：在上层结构中的属性名  </span></div><div class="line"><span class="comment">#           数据行：不用填  </span></div><div class="line">  </div><div class="line"><span class="comment">#    1  | required/optional | repeated  | required_struct/optional_struct   |  </span></div><div class="line"><span class="comment">#       | ------------------| ---------:| ---------------------------------:|  </span></div><div class="line"><span class="comment">#    2  | 属性类型          |           | 结构元素个数                      |  </span></div><div class="line"><span class="comment">#    3  | 属性名            |           | 结构类型名                        |  </span></div><div class="line"><span class="comment">#    4  | 注释说明          |           | 在上层结构中的属性名              |  </span></div><div class="line"><span class="comment">#    5  | 属性值            |           |                                   |</span></div></pre></td></tr></table></figure></p>
<p>当然可以参考github上下载到的样例表格，下载<a href="https://github.com/jameyli/tnt/" target="_blank" rel="external">tnt</a>项目，然后复制其中python目录下面的内容，其中xls文件中就有一个goods_info.xls的样例表格：<br><img src="http://img.blog.csdn.net/20160821230930642" alt=""></p>
<h4 id="2-xls-deploy-tool-py转换得到-data和-proto："><a href="#2-xls-deploy-tool-py转换得到-data和-proto：" class="headerlink" title="2.xls_deploy_tool.py转换得到.data和.proto："></a>2.xls_deploy_tool.py转换得到.data和.proto：</h4><p>进行导表的操作只需用在命令行中的一句指令即可完成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python xls_deploy_tool.py sheet_name xls_path</div></pre></td></tr></table></figure></p>
<p>其中包含两个参数：sheet_name是.xls中要进行导表的表格页名，xls_path是要进行导表的.xls文件的路径。创建一个测试工程Test_protobuf，将1中的两个文件和protoc.exe放入其中：<br><img src="http://img.blog.csdn.net/20160821231242376" alt=""><br>在命令行定位到该目录下，然后运行指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call python xls_deploy_tool.py GOODS_INFO xls/goods_info.xls</div></pre></td></tr></table></figure></p>
<p>运行结束后，该目录下多出了几个文件，但我们真正需要的只有两个文件，即.data数据文件和.proto解析类：<br><img src="http://img.blog.csdn.net/20160821231633799" alt=""><br><img src="http://img.blog.csdn.net/20160821231921863" alt=""></p>
<h4 id="3-得到最终解析类："><a href="#3-得到最终解析类：" class="headerlink" title="3.得到最终解析类："></a>3.得到最终解析类：</h4><p><code>protoc.exe</code>得到中间格式文件，假设后缀为.protodesc，使用指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protoc 输入文件路径(.proto文件) --descriptor_set_out=输出文件路径（.protodesc）</div></pre></td></tr></table></figure></p>
<p>在步骤2中的测试工程基础上继续执行指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protoc tnt_deploy_goods_info.proto --descriptor_set_out=goods_info.protodesc</div></pre></td></tr></table></figure></p>
<p>运行此步之后，在项目中又多出了一个与.proto对应的.protodesc文件：<br><img src="http://img.blog.csdn.net/20160821232254537" alt=""><br>protogen.exe得到.cs解析类，使用指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protogen -i:输入文件路径（.protodesc） -o:输出文件路径（.cs）</div></pre></td></tr></table></figure></p>
<p>将之前生成protogen.exe时protobuf-net-master\ProtoGen\bin\Release目录下面的所有文件复制到当前工程中，用一个文件夹ProtoGen来存放，假如不想执行这么繁琐的过程，也可以直接使用我编译好的ProtoGen文件目录压缩包：<a href="http://download.csdn.net/detail/linshuhe1/9609654" target="_blank" rel="external">ProtoGen.zip</a>，在当前项目的根目录下执行以下指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call ProtoGen\protogen -i:goods_info.protodesc -o:goods_info.cs</div></pre></td></tr></table></figure></p>
<p>执行结果，在当前目录下生成了解析类的最终状态goods_info.cs：<br><img src="http://img.blog.csdn.net/20160822114317374" alt=""></p>
<p>当然，以上三步可以直接用批处理来完成，直接在当前项目根目录下新建一个文件，命名为generator.bat，内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">call python xls_deploy_tool.py GOODS_INFO xls/goods_info.xls  </div><div class="line">call protoc tnt_deploy_goods_info.proto --descriptor_set_out=goods_info.protodesc  </div><div class="line">call ProtoGen\protogen -i:goods_info.protodesc -o:goods_info.cs  </div><div class="line">pause</div></pre></td></tr></table></figure></p>
<p>直接双击此文件即可完成以上所有操作生成最终的<code>.data</code>和<code>.cs</code>文件。<br><img src="http://img.blog.csdn.net/20160822114656222" alt="">  </p>
<h4 id="4-Unity导入库文件："><a href="#4-Unity导入库文件：" class="headerlink" title="4.Unity导入库文件："></a>4.Unity导入库文件：</h4><p>将几个文件添加到Unity工程中，将.data文件放在Assets\StreamingAssets\DataConfig目录下，将protobuf-net.dll和goods_info.cs放在Assets目录下：<br><img src="http://img.blog.csdn.net/20160822145729118" alt=""><br><img src="http://img.blog.csdn.net/20160822145805294" alt=""><br>创建一个Test.cs测试脚本，在脚本中<code>using Protobuf</code>用于导入protobuf-net.dll中的库，然后使用<code>using tnt_deploy</code>导入导表生成的.cs表格数据解析类，脚本具体代码内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">using UnityEngine;  </div><div class="line">using System.Collections;  </div><div class="line">using ProtoBuf;  </div><div class="line">using System.IO;  </div><div class="line">using tnt_deploy;  </div><div class="line">  </div><div class="line">public class Test : MonoBehaviour &#123;  </div><div class="line">    void Start () &#123;  </div><div class="line">        GOODS_INFO_ARRAY goods_infos = ReadOneDataConfig&lt;GOODS_INFO_ARRAY&gt;(&quot;goods_info&quot;);  </div><div class="line">        Debug.Log(&quot;goods_id==================&quot; + goods_infos.items[0].goods_id);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    private T ReadOneDataConfig&lt;T&gt;(string FileName)  </div><div class="line">    &#123;  </div><div class="line">        FileStream fileStream;  </div><div class="line">        fileStream = GetDataFileStream(FileName);  </div><div class="line">        if (null != fileStream)  </div><div class="line">        &#123;  </div><div class="line">            T t = Serializer.Deserialize&lt;T&gt;(fileStream);  </div><div class="line">            fileStream.Close();  </div><div class="line">            return t;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        return default(T);  </div><div class="line">    &#125;  </div><div class="line">    private FileStream GetDataFileStream(string fileName)  </div><div class="line">    &#123;  </div><div class="line">        string filePath = GetDataConfigPath(fileName);  </div><div class="line">        if (File.Exists(filePath))  </div><div class="line">        &#123;  </div><div class="line">            FileStream fileStream = new FileStream(filePath, FileMode.Open);  </div><div class="line">            return fileStream;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        return null;  </div><div class="line">    &#125;  </div><div class="line">    private string GetDataConfigPath(string fileName)  </div><div class="line">    &#123;  </div><div class="line">        return Application.streamingAssetsPath + &quot;/DataConfig/&quot; + fileName + &quot;.data&quot;;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Unity中新建一个场景，将Test.cs挂载在Main Camera主相机上，运行场景，看到打印结果，说明解析表格数据成功：<br><img src="http://img.blog.csdn.net/20160822145928497" alt=""> </p>
<h4 id="5-平台兼容问题："><a href="#5-平台兼容问题：" class="headerlink" title="5.平台兼容问题："></a>5.平台兼容问题：</h4><p>由于直接把protobuf-net.dll放到项目中时，在iOS中会出现<strong>JIT错误</strong>（ExecutionEngineException: Attempting to JIT compile method）。原因是因为iOS不允许JIT（Just In Time），只允许AOT（Ahead Of Time）。</p>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>直接把protprotobuf-net-master\protobuf-net目录下面的全部源码复制到Unity项目的目录下面，但是由于protobuf-net的编译过程是<strong>unsafe编译</strong>，所以Unity会出现编译报错：<br><img src="http://img.blog.csdn.net/20160822151338719" alt=""><br>需要<strong>在Assets目录下添加一个smsc.rsp文件</strong>，其内容很简单，只有一行“-unsafe”，添加完成后关闭Unity然后重新打开Unity，一切就正常了。</p>
<h3 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h3><p>虽然导表环境的配置过程比较繁琐，但是配置完成之后的工作效率却很高，而且proto具有突出的通用性，可以应用于各种语言环境。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis数据库]]></title>
      <url>http://yoursite.com/2016/09/08/Redis%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h2 id="Redis简介："><a href="#Redis简介：" class="headerlink" title="Redis简介："></a>Redis简介：</h2><p><strong>Redis</strong>是一种常用的Nosql（Not Only SQL，非关系型）数据库，遵守BSD协议，是一个高性能的<strong>key-value数据库</strong>，一般用来代替Memcached做缓存服务，同时，它也支持数据的持久化。</p>
<p>更详细的介绍可以查看<a href="http://redis.io/" target="_blank" rel="external">redis官网</a>，这里我们主要讲解一下如何安装和使用它。</p>
<a id="more"></a>
<p>Redis相比于其他key-value缓存产品，具有以下特点：</p>
<ul>
<li>支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；</li>
<li>不仅支持简单的key-value类型的数据，还提供对于list、set、zset、hash等数据结构的存储；</li>
<li>支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h2 id="Redis的安装和配置："><a href="#Redis的安装和配置：" class="headerlink" title="Redis的安装和配置："></a>Redis的安装和配置：</h2><h3 id="1-安装："><a href="#1-安装：" class="headerlink" title="1.安装："></a>1.安装：</h3><p>这里我下载的是最新的版本3.2.3：<a href="http://download.redis.io/releases/redis-3.2.3.tar.gz" target="_blank" rel="external">redis-3.2.3.tar.gz</a></p>
<p>下载</p>
<h3 id="2-配置："><a href="#2-配置：" class="headerlink" title="2.配置："></a>2.配置：</h3><h2 id="Redis的使用操作："><a href="#Redis的使用操作：" class="headerlink" title="Redis的使用操作："></a>Redis的使用操作：</h2><h3 id="1-启动："><a href="#1-启动：" class="headerlink" title="1.启动："></a>1.启动：</h3><h3 id="2-访问："><a href="#2-访问：" class="headerlink" title="2.访问："></a>2.访问：</h3><h3 id="3-关闭："><a href="#3-关闭：" class="headerlink" title="3.关闭："></a>3.关闭：</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity ShaderLab基础（三）Unity创建一个Shader]]></title>
      <url>http://yoursite.com/2016/09/07/Unity-ShaderLab%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Unity引擎是一个非常强大的支持跨平台开发的游戏引擎，基于Mono这个开源.Net的框架设计而成，在Unity中定义了<strong>ShaderLab</strong>来组织Shader的内容，针对不同平台进行编译。了解了Shader和Cg的一些基础知识之后，接下来我们要做的就是：学会如何在Unity中使用Cg编写Shader并实现一些简单的Shader效果。</p>
<a id="more"></a>
<h2 id="Unity-Shader："><a href="#Unity-Shader：" class="headerlink" title="Unity Shader："></a>Unity Shader：</h2><p>说到底，Shader其实只是一段规定好输入（颜色，贴图等）和输出（渲染器能读懂的点和颜色的对应关系）的程序。那么，<strong>设计一个Shader的过程其实就是根据输入，进行计算变换从而产生输出而已</strong>。</p>
<h3 id="1-分类："><a href="#1-分类：" class="headerlink" title="1.分类："></a>1.分类：</h3><p>在Unity中的Shader分为两类：</p>
<ul>
<li><strong>表面着色器</strong>（Surface Shader）:已经为我们完成了大部分的工作，只需要简单的操作即可得到不错的效果；</li>
<li><strong>片段着色器</strong>（Fragment Shader）:可以自己设计出很多东西，因为可自行设置的内容更多，但也更加难写。使用片段着色器的目的是可以在更加底层进行更复杂（或者针对目标设备更高效）的开发。</li>
</ul>
<h3 id="2-Shader程序基本结构："><a href="#2-Shader程序基本结构：" class="headerlink" title="2.Shader程序基本结构："></a>2.Shader程序基本结构：</h3><p>使用Unity中的框架来编写Shader程序，其实相对于其他游戏引擎要简单一些，在Cocos2d中还得从OpenGL层面开始编写逻辑，但是在Unity只需要往框架中填入需要控制的内容即可，一个Shader程序的基本结构如下图所示：</p>
<p><img src="http://i.imgur.com/a6T9fF8.png" alt=""></p>
<ul>
<li>首先，定义一些属性，用来指定代码将有哪些输入；</li>
<li>其次，会有一个或者多个子着色器，但是在实际运行中哪一个子着色器被使用是由运行的平台所决定的；</li>
<li>子着色器是代码的主体，每个子着色器包含一个或多个Pass；</li>
<li>最后指定一个回滚，用来处理所有Subshader都不能运行的情况（比如设备太老）。</li>
</ul>
<p>执行着色时，平台选择最优先可以使用的子着色器，然后依次执行该子着色器中的Pass，然后输出结果。</p>
<h3 id="3-Unity创建第一个Shader："><a href="#3-Unity创建第一个Shader：" class="headerlink" title="3.Unity创建第一个Shader："></a>3.Unity创建第一个Shader：</h3><p>在Unity的Project面板中，<code>右键</code>-<code>Create</code>-<code>Shader</code>，取名为<code>Diffuse_Texture</code>，使用VS打开可以查看新建的Shader的内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Shader &quot;Custom/Diffuse_Texture&quot; &#123;</div><div class="line">	Properties &#123;</div><div class="line">		_MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</div><div class="line">	&#125;</div><div class="line">	SubShader &#123;</div><div class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</div><div class="line">		LOD 200</div><div class="line">		</div><div class="line">		CGPROGRAM</div><div class="line">		#pragma surface surf Lambert</div><div class="line"></div><div class="line">		sampler2D _MainTex;</div><div class="line"></div><div class="line">		struct Input &#123;</div><div class="line">			float2 uv_MainTex;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		void surf (Input IN, inout SurfaceOutput o) &#123;</div><div class="line">			half4 c = tex2D (_MainTex, IN.uv_MainTex);</div><div class="line">			o.Albedo = c.rgb;</div><div class="line">			o.Alpha = c.a;</div><div class="line">		&#125;</div><div class="line">		ENDCG</div><div class="line">	&#125; </div><div class="line">	FallBack &quot;Diffuse&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们要做的，就是解析这个Shader中每一行的含义和作用，包括了属性、Tags、LOD、光照模型等。</p>
<h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a><strong>解析：</strong></h4><p>第一行指定了此Shader的名字，严格来说是指定了它的路径，在材质面板中选择Shader时，我们可以根据这个路径找到此Shader。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a><strong>属性</strong></h4><p>在<code>Properties{}</code>块中定义的内容就是着色器的属性，【可以理解为一些CPU语言例如java类在开始处定义的一些属性（全局变量或常量）】，<strong>这些属性将作为输入提供给所有的子着色器</strong>。每个属性定义的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_Name(&quot;Display_Name&quot;,type) = defaultValue[&#123;options&#125;]</div></pre></td></tr></table></figure></p>
<ul>
<li><code>_Name</code>：属性的名称，或者理解为变量名，在之后整个    Shader代码中通过此名称获取属性内容；</li>
</ul>
<ul>
<li><code>Display_Name</code>：此字符串是Shader在Unity的材质编辑器中作为Shader可视化信息；</li>
</ul>
<ul>
<li><code>type</code>：此属性的类型，Unity中支持的类型有：<ul>
<li>Color：颜色，由RGBA(红绿蓝和透明度)四个量定义；</li>
<li>2D：一张2的阶数大小（256，512等）的贴图，此贴图将在采样后被转为对应基于模型UV的每个像素的颜色，最终显示出来；</li>
<li>Rect：一个非2阶数大小的贴图；</li>
<li>Cube：即Cub map texture(立方体纹理)，即6张有联系的2D贴图的组合，主要用来做<strong>反射效果</strong>（比如：天空盒和动态反射），也会被转换为对应点的采样；</li>
<li>Range(min,max)：一个介于最大值max和最小值min之间的浮点数，一般用作调整Shader某些特性的参数（例如：透明度从0到1）；</li>
<li>Float：一个浮点数；</li>
<li>Vector：一个四维数；</li>
</ul>
</li>
<li><code>defaultValue</code>：定义的这个属性的默认值或者初始值，但不同属性类型的默认值格式不同，例如：<ul>
<li>Color：咦0~1定义的rgba颜色，可以赋值(1,1,1,1);</li>
<li>2D/Rect/Cube：贴图默认值需要是一个代表tini颜色的字符串，可以是空字符串或者”white”,”black”,”gray”,”bump”中的一个；</li>
<li>Float、Range：任意浮点数即可；</li>
<li>Vector：四维数，格式(x,y,z,w)；</li>
</ul>
</li>
<li><code>{option}</code>：只对2D、Rect和Cube贴图有关，初始值至少要在贴图后面写一对空白的<code>{}</code>，当需要打开特定选项时可以吧其写入到此花括号中，多个选项以空白分隔。可能的选项：ObjectLinear, EyeLinear, SphereMap, CubeReflect, CubeNormal，这些都是OpenGL中TexGen的模式。</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//颜色输入</div><div class="line">_MainColor (&quot;Main Color&quot;, Color) = (0,0.5,1,0.5)</div><div class="line">//2的阶数大小的贴图输入</div><div class="line">_Texture (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="Subshader"><a href="#Subshader" class="headerlink" title="Subshader"></a><strong>Subshader</strong></h4><p>上面已经解析了Shader代码的第一部分，接下来我们要将的就是Shader的代码主体，即SubShader的内容，在<code>SubShader{}</code>中的内容就是一个SubShader。</p>
<h5 id="1-Tags"><a href="#1-Tags" class="headerlink" title="(1) Tags"></a><strong>(1) Tags</strong></h5><p>SubShader中的第一句就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</div></pre></td></tr></table></figure></p>
<p>这是SubShader的标签，因为表面着色器可以被若干个标签（tags）所修饰，而<strong>硬件正是通过判定这些标签（Tags）来决定什么时候调用该着色器</strong>。所以，我们例子中的这一句<code>&quot;RenderType&quot;=&quot;Opaque&quot;</code>的意思：告诉系统应该在渲染非透明物体时调用此SubShader，这与RenderType是Opaque是相对应的。</p>
<p>此外，<strong>Tags其实也暗示了此Shader的输出情况</strong>，例如：输出中都是半透明的物体，那就写在Opaque里；如果想渲染透明或者半透明的像素，那就应该写在Transparent里。</p>
<p>另外比较有用的标签还有：</p>
<ul>
<li><code>&quot;IgnoreProjector&quot;=&quot;True&quot;</code>：不被Projects影响；</li>
<li><code>&quot;ForceNoShadowCasting&quot;=&quot;True&quot;</code>：从不产生阴影；</li>
<li><code>&quot;Queue&quot;=&quot;xxx&quot;</code>：<strong>指定渲染顺序队列</strong>。在Unity中，如果需要进行透明和不透明物体混合时，可能会遇到不透明物体无法呈现在透明物体之后的情况，这是由于Shader的渲染顺序不正确导致的。Queue指定物体渲染顺序，预定义的Queue有：<ul>
<li>Background：最早被调用的渲染，用于渲染天空盒或者背景；</li>
<li>Geometry：默认值，用来渲染非透明的物体；</li>
<li>AlphaTest：用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑；</li>
<li>Transparent：以后从后往前的顺序渲染透明物体；</li>
<li>Overlay：用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）；</li>
</ul>
</li>
</ul>
<p>以上这些预定义的值，本质上是一组定义<strong>整数</strong>，Background = 1000， Geometry = 2000, AlphaTest = 2450， Transparent = 3000，最后Overlay = 4000。当然，在实际设置Queue值时，不仅可以使用上述的预定义值，还可以指定自己的Queue值，例如：<code>&quot;Queue&quot;=&quot;Transparent+100&quot;</code>，表示一个在Transparent之后100的Queue上进行调用。</p>
<p><strong>通过调整Queue值，我们可以确保某些物体一定在另一个物体之前或之后被渲染</strong>。</p>
<h5 id="2-LOD"><a href="#2-LOD" class="headerlink" title="(2) LOD"></a><strong>(2) LOD</strong></h5><p>第二行中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOD 200</div></pre></td></tr></table></figure>
<p>LOD，即Level of Detail，这其实是<strong>Unity的内建Diffuse着色器的设定值，决定了我们能够用什么样的Shader</strong>。在Unity的Quality Settings中，我们可以设置允许的最大LOD，当设定的LOD小于SubShader的LOD时，这个SubShader将不可用。</p>
<p>Unity内建Shader定义了一组LOD的数值，我们在实现自己的Shader的时候可以将其作为参考来设定自己的LOD数值，这样在之后调整根据设备图形性能来调整画质时可以进行比较精确的控制。</p>
<ul>
<li>VertexLit及其系列 = 100</li>
<li>Decal, Reflective VertexLit = 150</li>
<li>Diffuse = 200</li>
<li>Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit = 250</li>
<li>Bumped, Specular = 300</li>
<li>Bumped Specular = 400</li>
<li>Parallax = 500</li>
<li>Parallax Specular = 600</li>
</ul>
<h5 id="2-CGPROGRAM…ENDCG"><a href="#2-CGPROGRAM…ENDCG" class="headerlink" title="(2) CGPROGRAM…ENDCG"></a><strong>(2) CGPROGRAM…ENDCG</strong></h5><p>用<code>CGPROGRAM</code>开始和<code>ENDCG</code>结束，表明这部分是Cg代码。这是SubShader的主体部分，我们前面已经提到了属性中定义了此Shader的输入，那么此处代码的作用，便是对输入进行处理，并输出。接下来我们逐句进行解析：</p>
<ul>
<li><code>#pragma surface surf Lambert</code>：这是一个编译指令，声明此Shader是一个表面着色器，并指定了着色器的自动调用的函数名称为surf,而且指定光照模型为Lambert(普通的diffuse)，它的一般语法如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#pragma surface surfaceFunction lightModel [optionalparams]</div></pre></td></tr></table></figure>
<ul>
<li>surface：声明的是一个表面着色器</li>
<li>surfaceFunction：着色器代码的方法名称，着色器其作用时被调用</li>
<li>lightModel：使用的光照模型</li>
</ul>
<hr>
<ul>
<li><code>sampler2D _MainTex;</code>：其中<code>sampler2D</code>是GLSL中2D贴图的类型，类似的还有sampler1D、sampler3D、samplerCube等格式，主要用于存储texture数据。<code>_MainTex</code>是与之前在Proterties属性模块中声明的图贴所对应的，因为这个Shader是由两个独立的程序块组成的：外部的属性声明和回滚等Unity可以直接使用和编译的ShaderLab；而在<code>CGPROGRAM...ENDCG</code>中的代码块，是一段CG程序。<strong>假如要在CG程序中访问Proterties中所定义的变量，必须使用和之前的变量相同的名字进行声明</strong>。所以此句Cg代码的作用就是<strong>再次声明并链接_MainTex，使接下来的Cg程序能够使用此变量</strong>。</li>
</ul>
<hr>
<ul>
<li>Input结构体：这其实是用来把需要参与计算的数据封装起来，然后作为输入参数传入到下面surf函数中使用的，而且必须以<code>Input</code>命名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct Input &#123;</div><div class="line">	float2 uv_MainTex;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里我们的Input结构体很简单，只是定义了一个float2类型的变量，这是Cg的数据类型，表示2个float类型的数据打包在一起，所以此处<code>uv_MainTex</code>表示的就是包含两个浮点数的变量，类似的还有float3和float4。</p>
<p>这里以uv作为前缀，其实UV mapping的作用是将一个2D贴图上的点按照一定规律映射到3D模型上，是3D渲染中最常见的一种顶点处理手段。所以在Cg中，在一个贴图变量（例如这里的_MainTex）前面加上uv，表示提取它的uv值（其实就是两个代表贴图上点的二维坐标）。后面的<strong>surf函数中直接通过访问uv_MainTex来去的这张贴图当前需要计算的点的坐标值</strong>。</p>
<hr>
<ul>
<li>surf函数：这是在之前<code>#progma</code>中指定的着色器的调用方法，这也是着色器最核心的部分，这个方法的定义需要按照规定：<strong>第一个参数是一个Input结构，第二个参数是一个inout的SurfaceOutput结构</strong>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void surf (Input IN, inout SurfaceOutput o) &#123;</div><div class="line">	half4 c = tex2D (_MainTex, IN.uv_MainTex);</div><div class="line">	o.Albedo = c.rgb;</div><div class="line">	o.Alpha = c.a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面已经说过了Input结构体的定义和使用，<strong>在计算输出时，Shader会多次调用surf函数，每次给入一个贴图上的点坐标，用来计算输出</strong>。</p>
<p>surf的第二个参数是一个可写的<code>SurfaceOutput</code>，SurfaceOutput是一个预定义的输出结构，我们的surf函数的目标就是根据输入把这个输出结构填上。SurfaceOutput结构体的定义如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct SurfaceOutput &#123;</div><div class="line">    half3 Albedo;     //像素的颜色</div><div class="line">    half3 Normal;     //像素的法向值</div><div class="line">    half3 Emission;   //像素的发散颜色</div><div class="line">    half Specular;    //像素的镜面高光</div><div class="line">    half Gloss;       //像素的发光强度</div><div class="line">    half Alpha;       //像素的透明度</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>half其实跟float与double类似，都是浮点数，只是精度不同，half称为半精度浮点数。</p>
<p>这个例子中，surf的代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">half4 c = tex2D (_MainTex, IN.uv_MainTex);</div><div class="line">o.Albedo = c.rgb;</div><div class="line">o.Alpha = c.a;</div></pre></td></tr></table></figure></p>
<p>这里的<code>tex2D</code>函数是Cg中用来在一张贴图中对点进行采样的方法，返回一个float4。这里，我们队_MainTex在输入点上进行采样，并将其颜色的rgb值<code>c.rgb</code>赋给输出的像素颜色<code>o.Albedo</code>，将透明度<code>c.a</code>赋值给输出像素透明度<code>o.Alpha</code>。</p>
<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ul>
<li>了解Shader的基础知识：<a href="https://onevcat.com/2013/07/shader-tutorial-1/" target="_blank" rel="external">猫都能学会的Unity3D Shader入门指南（一）</a></li>
<li>Unity官方关于Shader的一些资料：<a href="https://docs.unity3d.com/Manual/Shaders.html" target="_blank" rel="external">Materials, Shaders &amp; Textures</a></li>
<li>了解Shader的机制：<a href="http://blog.csdn.net/candycat1992/article/details/39994049" target="_blank" rel="external">【Unity Shaders】初探Surface Shader背后的机制</a></li>
</ul>
<h4 id="推荐书籍："><a href="#推荐书籍：" class="headerlink" title="推荐书籍："></a>推荐书籍：</h4><ul>
<li>《Unity Shader and Effect Cookbook》，中文版：《Unity着色器和屏幕特效开发秘笈》</li>
<li>《GPU 编程与CG 语言之阳春白雪下里巴人》</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity ShaderLab基础（二）Cg语言]]></title>
      <url>http://yoursite.com/2016/09/06/Unity-ShaderLab%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>学习一门新的语言，有几个基本需要掌握的：数据类型（基本数据类型和结构类型），基本语法（表达式和控制语句等），编译和运行方式，这一点在CPU编程语言和GPU编程语言中是相似的，Cg作为一门GPU图形学语言也是如此。<br><a id="more"></a></p>
<h2 id="Cg的数据类型："><a href="#Cg的数据类型：" class="headerlink" title="Cg的数据类型："></a>Cg的数据类型：</h2><h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h3><p>Cg支持7种基本的数据类型，分别是：</p>
<ul>
<li><strong>float</strong>， 32 位浮点数据，一个符号位。浮点数据类型被所有的 profile 支持</li>
<li><strong>half</strong>，16 为浮点数据</li>
<li><strong>int</strong>，32 位整形数据，有些 profile 会将 int 类型作为 float 类型使用</li>
<li><strong>fixed</strong>，12 位定点数，被所有的 fragment profiles 所支持</li>
<li><strong>bool</strong>，布尔数据，通常用于 if 和条件操作符（ ?: ） ，布尔数据类型被所有的profiles 支持</li>
<li><strong>simpler*</strong>， 纹理对象的句柄（ the handle to a texture object ） ，分为 6 类：<br>sampler, sampler1D, sampler2D, sampler3D, samplerCUBE, 和 samplerRECT 。DirectX profiles 不支持 samplerRECT 类型， 除此之外这些类型被所有的 pixelprofiles 和 NV40 vertex program profile 所支持（ CgUsersManual 30 页） 。由此可见，在不远的未来，顶点程序也将广泛支持纹理操作</li>
<li><strong>string</strong>，字符类型，该类型不被当前存在的 profile 所支持，实际上也没有必要在 Cg 程序中用到字符类型，但是你可以通过 Cg runtime API 声明该类型变量，并赋值；因此，该类型变量可以保存 Cg 文件的信息。</li>
</ul>
<blockquote>
<p>前6种类型为常用类型，<strong>string</strong>类型几乎不使用。</p>
</blockquote>
<h3 id="2-其他内置数据类型："><a href="#2-其他内置数据类型：" class="headerlink" title="2.其他内置数据类型："></a>2.其他内置数据类型：</h3><ul>
<li><strong>向量</strong></li>
</ul>
<p>Cg还提供了内置的向量数据类型 (built-in vector data types) ，内置的向量数据类型基于基础数据类型。 例如： float4， 表示 float 类型的 4 元向量； bool4， 表示 bool类型 4 元向量。<br>（注意： <strong>向量最长不能超过 4 元</strong>， 即在 Cg 程序中可以声明 float1 、 float2 、 float3 、float4 类型的数组变量，但是不能声明超过 4 元的向量。）<br>向量初始化方式一般为：</p>
<pre><code>float4 array = float4(1.0, 2.0, 3.0, 4.0);
</code></pre><p>较长的向量还可以通过较短的向量进行构建：</p>
<pre><code>float2 a = float2(1.0, 1.0);  
float4 b = float4(a, 0.0, 0.0);  
</code></pre><ul>
<li><strong>矩阵</strong></li>
</ul>
<p>Cg还提供矩阵数据类型，不过<strong>最大的维数不能超过4X4阶</strong>，例如：</p>
<pre><code>float1x1 matrix1;//等价于float matirx1; x是字符，并不是乘号！  
float2x3 matrix2;//表示 2*3 阶矩阵，包含6个float类型数据  
float4x2 matrix3;//表示 4*2 阶矩阵，包含8个float类型数据  
float4x4 matrix4;//表示 4*4 阶矩阵，这是最大的维数  
</code></pre><p>矩阵初始化：</p>
<pre><code>float2x3 matrix5 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0};  
</code></pre><ul>
<li><strong>数组</strong></li>
</ul>
<p><strong>数组数据类型在Cg中的作用：作为函数的形参，用于大量数据的传递</strong>，例如：顶点参数数组、光照参数数据等。</p>
<p>一维数组：</p>
<pre><code>float a[10];//声明了一个数组，包含 10 个 float 类型数据  
float a[4] = {1.0, 2.0, 3.0, 4.0}; //初始化一个数组  
int length = a.length;//获取数组长度  
</code></pre><p>多维数组：</p>
<pre><code>float b[2][3] = {{0.0, 0.0, 0.0},{1.0, 1.0, 1.0}};  
int length1 = b.length; // length1 值为 2  
int length2 = b[0].length; // length2 值为 3  
</code></pre><p>注：在Cg中，向量、矩阵与数组是完全不同的，向量和矩阵是内置的数据类型，而数组则是一种数据结构。</p>
<ul>
<li><strong>类型转换</strong></li>
</ul>
<p>Cg 中的类型转换和 C 语言中的类型转换很类似。 C 语言中类型转换可以是<strong>强制类型转换</strong>，也可以是<strong>隐式转换</strong>，如果是后者，则数据类型从低精度向高精度转换。在 Cg 语言中也是如此：</p>
<pre><code>float a = 1.0;  
half b = 2.0;  
float c = a+b; //等价于 float c = a + (float)b;  
</code></pre><p>当有类型变量和无类型常量数据进行运算时，该常量数据不做类型转换，例如：</p>
<pre><code>float a = 1.0;  
float b = a + 2.0;//2.0为无类型常量数据，编译时作为float 类型
</code></pre><p>Cg 语言中对于常量数据可以加上类型后缀，表示该数据的类型，例如：</p>
<pre><code>float a = 1.0;  
float b = a + 2.0h;//2.0h为half类型常量数据，运算是需要做类型转换
</code></pre><p>常量的类型后缀有3种：</p>
<ul>
<li>f：表示float</li>
<li>h：表示half</li>
<li>x：表示fixed</li>
</ul>
<hr>
<h2 id="Cg的语法："><a href="#Cg的语法：" class="headerlink" title="Cg的语法："></a>Cg的语法：</h2><p>Cg的关系操作符、逻辑操作符、位移操作符都与C语言有相似之处，需要特别注意的是<strong>Swizzle操作符</strong>，例如：</p>
<pre><code>float4(a, b, c, d).xyz     //等价于 float3(a, b, c)
float4(a, b, c, d).xyy     //等价于 float3(a, b, b)
float4(a, b, c, d).wzyx //等价于 float4(d, c, b, a)
float4(a, b, c, d).w     //等价于 float d
</code></pre><hr>
<h2 id="Cg的编译："><a href="#Cg的编译：" class="headerlink" title="Cg的编译："></a>Cg的编译：</h2><h3 id="1-编译方式："><a href="#1-编译方式：" class="headerlink" title="1.编译方式："></a>1.编译方式：</h3><ul>
<li><strong>编译程序</strong>：</li>
</ul>
<p>计算机只能理解和执行由 0 、 1 序列（电压序列）构成的机器语言，所以汇编语言和高级语言程序都需要进行翻译才能被计算机所理解， 担负这一任务的程序称为语言处理程序，通常也被称为编译程序。</p>
<ul>
<li><strong>静态编译</strong>：</li>
</ul>
<p>一旦编译后，除非改变程序代码，否则不需要重新编译，这种方式称为静态编译（ static compilation ） 。静态编译最重要的特征是：<strong>一旦编译为可执行文件，在可执行文件运行期间不再需要源码信息</strong>。</p>
<ul>
<li><strong>动态编译</strong>：</li>
</ul>
<p>编译程序和源码都要参与到程序的运行过程中，就像脚本语言（Lua、JavaScrpit等），源码嵌套到调用的宿主语言程序中，运行时进行编译。</p>
<p><strong>Cg通常采用动态编译的方式（Cg也支持静态编译方式），即在宿主程序运行时，利用Cg运行库（Cg Runtimer Library）动态编译Cg代码。使用动态编译的方式，可以将Cg程序当做一个脚本，随时修改随时运行，节省时间，在OGRE图形引擎中就采用了这种方式。</strong></p>
<h3 id="2-编译器："><a href="#2-编译器：" class="headerlink" title="2.编译器："></a>2.编译器：</h3><p>Cg 编译器首先将 Cg 程序翻译成可被图形 API （ OpenGL 和 Direct3D ）所接受的形式， 然后应用程序使用适当的 OpenGL 和 Direct3D 命令将翻译后的 Cg 程序传递给图形处理器， OpenGL 和 Direct3D 驱动程序最后把它翻译成图形处理器所需要的硬件可执行格式。<strong>NVIDIA 提供的 Cg 编译器为 cgc.exe</strong>。</p>
<ul>
<li>下载<a href="https://developer.nvidia.com/cg-toolkit-download" target="_blank" rel="external">Cg Toolkit</a>；</li>
<li>安装之后，在安装目录的Cg\bin中就有cgc.exe；</li>
<li>打开命令行窗口，输入 <code>cgc -h</code> ，假如不报错则说明安装成功。</li>
</ul>
<h3 id="3-Cg指令："><a href="#3-Cg指令：" class="headerlink" title="3.Cg指令："></a>3.Cg指令：</h3><p><strong>编译指令</strong></p>
<pre><code>cgc [options] file
</code></pre><ul>
<li><code>[options]</code> 表示可选配置项;</li>
<li><code>file</code> 表示 Cg 程序文件名。</li>
</ul>
<p>例如，比较典型的编译方式：</p>
<pre><code>cgc -profile glslv -entry main_v test.cg
</code></pre><ul>
<li><code>-profile</code> 是profile配置项名；</li>
<li><code>glslv</code> 是当前所使用的profile名称；</li>
<li><code>-entry</code> 着色程序的入口函数名称配置项；</li>
<li><code>main_v</code> 是顶点着色程序的入口函数名；</li>
<li><code>test.cg</code> 是当前的着色程序文件名（必须带后缀名）,Cg源码文件需以<strong>.cg</strong>为后缀名；</li>
</ul>
<p>将Cg语言所写的着色程序转换为使用<strong>GLSL</strong>或<strong>HLSL</strong>所编写的程序：</p>
<pre><code>cgc –profile glslv –o direct.glsl –entry main_v test.cg
</code></pre><p>表示编译文件 test.cg 中的顶点着色程序， 入口函数名为 main_v ， 并将顶点着色程序转换为 glsl 程序，然后保存成文件 direct.glsl 。</p>
<p><strong>备注</strong>：GPU编程，是无法跟踪调试着色程序的，一个着色程序，语法错误可以通过编译器发现，但是代码的逻辑错误只能认真查找。</p>
<blockquote>
<p>关于Cg的更详细的介绍可以参考这篇博客，利用OpenGL、C++和Cg进行Cg的测试：<a href="http://blog.csdn.net/xiajun07061225/article/details/6937272" target="_blank" rel="external">【GPU编程】开始Cg之旅，编译自己的第一个Cg程序</a></p>
</blockquote>
<h3 id="4-Cg-Profiles"><a href="#4-Cg-Profiles" class="headerlink" title="4.Cg Profiles:"></a>4.<strong>Cg Profiles:</strong></h3><p>Cg 程序的编译不但依赖于宿主程序所使用的三维编程接口，而且依赖于图形硬件环境，因为图形硬件自身的限制，不一定支持某种 Cg 语句。<br><strong>被特定的图形硬件环境或 AIP 所支持的 Cg 语言子集，被称为Cg Profiles</strong> 。</p>
<p>profile分为：<strong>顶点程序的profile</strong>和<strong>片段程序的profile</strong>，所以编译顶点着色程序时必须选用当前图形硬件支持的顶点profile ，同理，编译片段着色程序时必须选用当前图形硬件支持的片段profile 。</p>
<p>顶点 profile 和片段 profile 又基于 OpenGL 和 DirectX 的不同版本或扩展，划分为各种版本，当前 Cg compiler 所支持的 profiles 有：</p>
<pre><code>OpenGL ARB vertex programs
        Runtime profile: CG_PROFILE_ARBVP1
        Compiler option: _profile arbvp1
OpenGL ARB fragment programs
        Runtime profile: CG_PROFILE_ARBFP1
        Compiler option: _profile arbfp1
......
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unity ShaderLab基础（一）概述]]></title>
      <url>http://yoursite.com/2016/09/05/Unity-ShaderLab%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="什么是Shader"><a href="#什么是Shader" class="headerlink" title="什么是Shader?"></a>什么是Shader?</h2><h3 id="1-Shader的概念："><a href="#1-Shader的概念：" class="headerlink" title="1.Shader的概念："></a>1.Shader的概念：</h3><p><strong>Shader</strong>，即着色器，是一种运行在GPU上的程序，用来对三维物体进行着色处理、光和影的计算、纹理颜色的呈现等，从而将一个个作为抽象的几何数据存在的模型、场景和特效，以近似于真实世界的光与影的形式呈现出来。（简单点的理解就是：利用GPU编程使得构件出来的对象近似于真实世界中的对象呈现出来的处理）<strong>通过Shader可以改变物体的形状、大小、位置以及旋转等</strong>。<br><a id="more"></a></p>
<h3 id="2-Shader和Material的关系："><a href="#2-Shader和Material的关系：" class="headerlink" title="2.Shader和Material的关系："></a>2.Shader和Material的关系：</h3><p>Shader负责将输入的Mesh(网格)以指定的方式和输入的贴图或者颜色等组合起来输出，绘图单元可以依据这个输出来将图像绘制在屏幕之上。输入的贴图或颜色，加上对应的Shader和Shader的特定参数设置，这些打包存储在一起就得到了一个Material。</p>
<h3 id="3-以面向对象的思想理解Shader："><a href="#3-以面向对象的思想理解Shader：" class="headerlink" title="3.以面向对象的思想理解Shader："></a>3.以面向对象的思想理解Shader：</h3><p>假设把Shader当做一个类，那么在对某个物体使用此Shader时，就需要实例化此Shader，得到一个对象，而<strong>Material就相当于是一个Shader的对象</strong>。</p>
<h3 id="4-Shader的分类："><a href="#4-Shader的分类：" class="headerlink" title="4.Shader的分类："></a>4.Shader的分类：</h3><p>Shader的基础类型有两种：<strong>顶点Shader</strong>和<strong>片段Shader</strong>，它们的特点：</p>
<ul>
<li><strong>顶点Shader</strong>：具有可以处理、变换，最终会渲染到屏幕上的网格物体的顶点位置的功能，但它不能生成新的顶点；</li>
<li><strong>片段Shader</strong>：会对一个片段（预备像素）进行各种测试，如Z深度测试、Alpha比较测试，能通过各种测试的片段，最终会被写入渲染的输出帧中，从而成为屏幕上的一个可见像素。</li>
</ul>
<h2 id="GPU编程和Shader的编程语言"><a href="#GPU编程和Shader的编程语言" class="headerlink" title="GPU编程和Shader的编程语言"></a>GPU编程和Shader的编程语言</h2><h3 id="1-GPU编程简介："><a href="#1-GPU编程简介：" class="headerlink" title="1.GPU编程简介："></a>1.GPU编程简介：</h3><p><strong>GPU</strong>——Programmable Graphics Processing Unit，即可编程图形处理单元，也成为可编程图形硬件，至于GPU上的编程，实质上就是GPU允许应用程序指定一个序列的指令进行顶点操作控制</p>
<h3 id="2-Shader的编程语言："><a href="#2-Shader的编程语言：" class="headerlink" title="2.Shader的编程语言："></a>2.Shader的编程语言：</h3><p>GPU与CPU是截然不同的，这不仅仅再其硬件结构的差异上，这也就决定了在两者运行环境下的编程过程也是不同的。目前面向GPU的编程，有<strong>3种高级图像语言</strong>，分别是：</p>
<ul>
<li>微软的 <strong>HLST</strong> (High Level Shading Language)，是通过Direct3D图形软件库来写Shader程序的语言；</li>
<li>OpenGL提供的 <strong>GLSL</strong> (OpenGL Shading Language)来写Shader程序；</li>
<li>NVIDIA提供的 <strong>Cg</strong> (C for graphics)语言（以HLST为基础，很相似），兼容Direct3D和OpenGL图形接口；</li>
</ul>
<p>考虑到最大化的跨平台支持，选择使用兼容性最高的 <strong>Cg</strong> 作为编写Shader的语言，但假如只针对Unity 3D引擎，也可以选择 <strong>GLSL</strong>。</p>
<h2 id="如何使用Cg编写Shader："><a href="#如何使用Cg编写Shader：" class="headerlink" title="如何使用Cg编写Shader："></a>如何使用Cg编写Shader：</h2><p>在开始进行实际的编程之前，我们应该先清楚实现步骤，这就需要我们了解一下GPU进行图形绘制的操作步骤。</p>
<h3 id="1-GPU图形绘制："><a href="#1-GPU图形绘制：" class="headerlink" title="1.GPU图形绘制："></a>1.GPU图形绘制：</h3><p>用图形绘制管线描述GPU渲染流程，即“给定视点、三维物体、光源、照明模式和纹理等元素，如何绘制一幅二维图像”。图像绘制其实分为三个阶段：<strong>应用程序阶段</strong>、<strong>几何阶段</strong>和<strong>光栅阶段</strong>：</p>
<ul>
<li><strong>应用程序阶段</strong>：使用高级语言（C、C++等）进行开发，主要和CPU、内存打交道，诸如：碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段。<strong>在该阶段末端，几何体数据（顶点坐标、法向量、纹理等）通过数据总线传送给图形硬件</strong>。</li>
<li><strong>几何阶段</strong>：主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，该阶段基于GPU进行计算。<strong>在该阶段末端，得到经过变换和投影之后的顶点坐标、颜色、以及纹理坐标</strong>。</li>
<li><strong>光栅阶段</strong>：基于几何阶段的输出数据，为像素（Pixel）正确配色，以便绘制完整图像，该阶段进行的都是单个像素的操作，每个像素的信息存储在颜色缓冲器（color buffer或者frame buffer）中。</li>
</ul>
<p>（例如：光照计算属于几何阶段、雾化以及涉及物体透明度的计算属于光栅阶段、深度信息（Z值）的计算属于几何阶段并传递给光栅阶段。）</p>
<h3 id="2-Unity中使用Cg写Shader："><a href="#2-Unity中使用Cg写Shader：" class="headerlink" title="2.Unity中使用Cg写Shader："></a>2.Unity中使用Cg写Shader：</h3><p>基本步骤如下：</p>
<ul>
<li>定义一些属性，用于指定此Shader将有哪些输入；</li>
<li>定义一个或者多个子着色器，每个着色器中包含一个或者多个Pass；</li>
<li>指定一个回滚，用于处理所有SubShader都不能运行的情况。 </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Next主题的fancybox展示图片]]></title>
      <url>http://yoursite.com/2016/09/03/Next%E4%B8%BB%E9%A2%98%E7%9A%84fancybox%E5%B1%95%E7%A4%BA%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在创建的文章开头假如图片，并且支持点击放大功能，这是Next主题包含的一个功能。</p>
<a id="more"></a>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>使用方法就是在开头匹配内容中假如<code>photos</code>字段，可以加图片链接列表：</p>
<pre><code>---
title: Next主题的fancybox展示图片
date: 2016-09-03 17:15:22
tags:
photos:
- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg
- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg
---
</code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>此案例的运行结果，如本文的开头所示。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BATCH批处理简记]]></title>
      <url>http://yoursite.com/2016/09/03/BATCH%E6%89%B9%E5%A4%84%E7%90%86%E7%AE%80%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文转载自原文<a href="http://www.jb51.net/article/7131_3.htm" target="_blank" rel="external">批处理经典入门教程！(从不懂到高手)</a>，只是原文作者太罗嗦了，我做了稍微的简化。</p>
</blockquote>
<ol>
<li>批处理定义</li>
<li>基本语法和常用命令</li>
<li>例子</li>
</ol>
<a id="more"></a>
<hr>
<h3 id="一-批处理定义"><a href="#一-批处理定义" class="headerlink" title="一.批处理定义"></a>一.批处理定义</h3><p>批处理的本质，其实是一堆DOS命令，他们按一定顺序排列而形成的集合就是批处理。批处理，也称为批处理脚本，英文译为BATCH，批处理文件后缀BAT就取的前三个字母。<br><strong>注意：</strong>批处理的每一行可视为一个命令，每个命令里可以含多条子命令，从第一行开始执行，直到最后一行结束，它运行的平台是DOS。</p>
<hr>
<h3 id="二-基本语法和常用命令"><a href="#二-基本语法和常用命令" class="headerlink" title="二.基本语法和常用命令"></a>二.基本语法和常用命令</h3><p>1.注释方式：<br>使用“::”双冒号的方式进行注释，注释符号之后的同一行中的内容在脚本执行时不显示，也不起任何作用，只是增加了脚本的可读性，在批处理脚本中和rem命令等效。例如：</p>
<pre><code>@echo off 
::close echo 
cls 
::clean screen 
</code></pre><p>2.@符号：<br>让脚本执行窗口不显示此符号之后指令内容的命令本身，而只显示执行结果，就像上例中的“@echo off”，@可以使得doc中不显示echo off，而直接显示其执行的结果。</p>
<p>3.echo:<br>可以看做是回写或者是反馈，但实际上它是一个开关，而控制它的指令就是echo on和echo off了，而直接执行echo指令则会显示当前echo所处的状态（on或off）。执行echo off将关闭回显，它后面的所有命令都不显示命令本身，只显示执行后的结果，除非执行echo on命令。<br>echo命令的另一种用法一：可以用它来显示信息，如：```echo hello world<code>,会在doc中打印“hello world”;
echo命令的另一种用法二：可以直接编辑文本文件,如：在doc窗口直接输入</code>echo nbtstat -A 192.168.0.1 &gt; a.bat ````，执行结果会在当前目录下创建一个a.bat文件。</p>
<p>4.pause:<br>直接可以看出它是“暂停”的意思，即让当前程序进程暂停一下，并显示一行信息：请按任意键继续. . .。</p>
<p>5.”goto”和”:”:<br>这两个指令是以一个组合形式出现的，goto是一个跳转指令，一般脚本执行到goto指令时，会跳转到：:标签定义的部分区执行。例如：</p>
<pre><code>goto usage
...
:usage
...
</code></pre><p>不难看出，goto命令就是根据这个冒号和标签名称来寻找它该跳转的地方，它们是一一对应的关系，goto命令也经常和if命令结合使用。<br>goto命令的另一种用法一：提前结束程序。在程序中间使用goto命令跳转到某一标签，而这一标签的内容却定义为退出。<br>如： </p>
<pre><code>…… 
goto end 
…… 
:end 
</code></pre><p>这里:end在脚本最后一行！</p>
<p>6.%:<br>单个%不算是命令，而相当于参数，例如：</p>
<pre><code>net use \\%1\ipc$ %3 /u:&quot;%2&quot; 
copy 11.BAT \\%1\admin$\system32 /y 
copy 13.BAT \\%1\admin$\system32 /y 
copy ipc2.BAT \\%1\admin$\system32 /y 
copy NWZI.EXE \\%1\admin$\system32 /y 
attrib \\%1\admin$\system32⏺.bat -r -h -s 
</code></pre><p>以上代码是Bat.Worm.Muma病毒中的一部分，%1代表的IP，2%代表的username，3%代表password。执行形式为：脚本文件名 参数一 参数二 ……。假设这个脚本被保存为a.bat，则执行形式如下：a IP username password。这里IP、username、password是三个参数，缺一不可（因为程序不能正确运行，并不是因为少了参数语法就不对）这样在脚本执行过程中，脚本就自动用用你的三个参数依次（记住，是依次！也是一一对应的关系。）代换1%、2%和3%，这样就达到了灵活运用的目的。 </p>
<hr>
<h3 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h3><p>将所需的命令都写在一个文件中，并且修改文件的后缀名为.bat，双击执行即会弹出doc窗口执行文件中的脚本命令。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python Web 1 —— python和MongoDB安装]]></title>
      <url>http://yoursite.com/2016/09/03/Python-Web-1-%E2%80%94%E2%80%94-python%E5%92%8CMongoDB%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<blockquote>
<p>做了很长时间的客户端，主要从事过Android软件开发和Unity 3D的游戏开发，之前还看过一段时间的Java Web，但是由于没有实际的应用，所以就搁置了很久。最近突然有对服务器后台编程产生了浓厚的兴趣，想试着用Python + Mongo DB进行游戏后台的开发。</p>
</blockquote>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python是一门具有强类型(即变量类型是强制要求的)、动态性、隐式类型(不需要做变量声明)、大小写敏感(var和VAR代表了不同的变量)以及面向对象等特点的编程语言。<strong>Python是一种解释型的语言，相比于C语言，Python的运行速度慢，且不能进行加密。</strong><br><a id="more"></a></p>
<h4 id="一、Python的安装："><a href="#一、Python的安装：" class="headerlink" title="一、Python的安装："></a>一、Python的安装：</h4><p>由于我使用的开发环境是Mac OS，所以自带了Python，但由于10.10自带的版本是2.7的，所以我们需要重新安装3.x的版本，安装方法：</p>
<p> 1.没有安装Homebrew的先安装此Mac插件，安装方法就是打开终端，输入以下指令：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></div></pre></td></tr></table></figure></p>
<p>2.使用以下指令安装Python3：</p>
<ul>
<li>先查看当前计算机的python版本：<strong>python</strong></li>
</ul>
<p><img src="http://img.blog.csdn.net/20160611163033678" alt="这里写图片描述"></p>
<ul>
<li>安装新版本：<strong>brew install python3</strong></li>
</ul>
<p><img src="http://img.blog.csdn.net/20160611163202196" alt="这里写图片描述"><br>这里我的安装出错了，出错不可怕，解决就好了，不难看出这个错误出现的原因是对/usr/local/share/man/man3目录的权限不够，那么解决方法：<strong>sudo chown -R linshuhe /usr/local/share/man/man3</strong><br><img src="http://img.blog.csdn.net/20160611172025531" alt="这里写图片描述"><br>但是，这里又出现了多版本的python共存和版本切换的问题了：<br><img src="http://img.blog.csdn.net/20160611172635305" alt="这里写图片描述"><br>假如不想修改或者删除系统自带的python，我们可以直接通过以下方式指定使用哪个版本执行代码：<br><img src="http://img.blog.csdn.net/20160611173455348" alt="这里写图片描述"></p>
<p>除了上述方法之外，还可以直接到官网下载最新版本，直接安装即可。</p>
<hr>
<h3 id="Mongo-DB"><a href="#Mongo-DB" class="headerlink" title="Mongo DB"></a>Mongo DB</h3><h4 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h4><p>使用Homebrew进行安装是比较简单的安装方式：<br>1.更新Homebrew:<strong>brew update</strong><br><img src="http://img.blog.csdn.net/20160610091546638" alt="这里写图片描述"><br>2.开始安装mongodb:<strong>brew install mongodb</strong><br><img src="http://img.blog.csdn.net/20160610091527985" alt="这里写图片描述"><br>3.根据安装完成最后的提示，启动mongodb:<br><strong>mongod —config /usr/local/etc/mongod.conf</strong></p>
<p>4.下载一个可视化管理工具Robomongo：下载的地址为：<br><a href="https://robomongo.org/download" target="_blank" rel="external">https://robomongo.org/download</a><br><img src="http://img.blog.csdn.net/20160610091457232" alt="这里写图片描述"></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Github Pages + Hexo创建个人博客]]></title>
      <url>http://yoursite.com/2016/09/02/Github-Pages+Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>之前使用过jekyll+github做过一版自己的博客网站，有兴趣的可以看一下我之前的文章：<a href="http://blog.csdn.net/linshuhe1/article/details/51143026" title="Github+Jekyll —— 创建个人免费博客（一）从零开始" target="_blank" rel="external">http://blog.csdn.net/linshuhe1/article/details/51143026</a>，其实也很简单，但是存在一些问题：目录、Rss、sitemap无法自动生成。</p>
</blockquote>
<hr>
<blockquote>
<p>最近看到了别人使用hexo+github实现的博客，有更多的灵活性和简约的风格，所以也试着改一下自己原本的设计。</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是hexo："><a href="#什么是hexo：" class="headerlink" title="什么是hexo："></a>什么是hexo：</h2><p><code>hexo</code>是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管到github或者Heroku上，类似于jekyll、Octopress、Wordpress等，使用markdown来写文章。hexo的作者是<a href="https://github.com/tommy351/hexo" title="@tommy351" target="_blank" rel="external">https://github.com/tommy351/hexo</a>。具有以下几点优点：</p>
<ul>
<li>易用性，部署很简单，常用指令有：<code>hexo new</code>、<code>hexo generate</code>、<code>hexo server</code>、<code>hexo deploy</code>；</li>
<li>轻量级，文件少而小，自定义方便</li>
</ul>
<h2 id="相关知识："><a href="#相关知识：" class="headerlink" title="相关知识："></a>相关知识：</h2><p>hexo配置过程中使用到了<code>Github</code>，<code>Git</code>，<code>Markdown</code>，<code>Node.js</code>等相关操作，所以需要很多插件、widget需要自己安装配置。</p>
<h2 id="安装准备："><a href="#安装准备：" class="headerlink" title="安装准备："></a>安装准备：</h2><ol>
<li>Node.js:<a href="https://nodejs.org/en/" title="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a> ；</li>
<li>Github桌面版（Windows）：<a href="https://desktop.github.com/" title="https://desktop.github.com/" target="_blank" rel="external">https://desktop.github.com/</a>；</li>
</ol>
<h2 id="安装Github桌面版和配置"><a href="#安装Github桌面版和配置" class="headerlink" title="安装Github桌面版和配置"></a>安装Github桌面版和配置</h2><ol>
<li>双击下载好的<code>GitHubSetup.exe</code>文件，按照默认设置完成安装；</li>
<li>登录自己的github账号；</li>
</ol>
<p><img src="http://i.imgur.com/97nOEVO.png" alt=""></p>
<ol>
<li>在github网页上创建一个以<code>username.github.io</code>命名的repositories,此时username为自己github的账号名称；</li>
</ol>
<p><img src="http://i.imgur.com/A9cQrk6.png" alt=""></p>
<ol>
<li>打开Git Shell，使用配置SSH Key使本地git项目与远程Github建立联系：<code>ssh -T git@github.com</code>；</li>
</ol>
<p><img src="http://i.imgur.com/t33BM1G.png" alt=""></p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>直接双击下载好的<code>node-v4.5.0-x64.msi</code>选择指定的安装路径，按照默认设置完成安装操作，安装完成后不需要对Node.js进行任何配置。为了检验是否完成安装，可以打开命令行，输入指令：<code>npm --version</code>进行版本号查询。<br><img src="http://i.imgur.com/H21hK8M.png" alt=""></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo:"></a>安装Hexo:</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装:"></a>1.安装:</h3><pre><code>mkdir hexo #创建一个项目文件
cd hexo    #进入项目文件目录
npm install -g hexo-cli
npm install hexo --save
</code></pre><p>npm是Node.js中的一个工具，所以在安装Hexo之前应该先安装Node.js</p>
<h3 id="2-部署Hexo："><a href="#2-部署Hexo：" class="headerlink" title="2.部署Hexo："></a>2.部署Hexo：</h3><p>在Git shell中输入：</p>
<pre><code>hexo init
</code></pre><p>记得输入之前需要确保当前命令行所处目录为所要创建工程的根目录下，因为此操作的结果就是将hexo的一些必要文件复制到当前目录下面。<br><img src="http://i.imgur.com/8bOaggs.png" alt=""><br>看到上图结果之后，可以通过以下指令运行博客：</p>
<pre><code>hexo server
</code></pre><p><img src="http://i.imgur.com/OyexMqN.png" alt=""><br>运行正常的话可以通过访问：<a href="http://localhost:4000/" title="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>查看运行结果：</p>
<p><img src="http://i.imgur.com/Xy731Ig.png" alt=""></p>
<p>假如出现了hexo服务启动成功，但是浏览器访问localhost:4000一直不响应，那就有可能是因为你的设备上装了其他软件占用了4000端口，一般有两种办法可以解决：</p>
<ul>
<li>在服务管理中将占用该端口的服务停止掉，通常安装了福昕阅读器的就会占用4000，把其对应的后台服务关掉即可；</li>
<li><p>切换hexo启动的默认端口，使用以下指令：</p>
<p>  hexo s -p 5000</p>
</li>
</ul>
<p>此时启动端口就变成了5000，访问地址变成了localhost:5000。</p>
<h3 id="3-安装Hexo插件："><a href="#3-安装Hexo插件：" class="headerlink" title="3.安装Hexo插件："></a>3.安装Hexo插件：</h3><p>主要目的是为了让其自动生成sitemap，Rss，部署到git等，这些是额外的插件，假如不需要使用到这些功能可以不添加：</p>
<pre><code>npm install hexo-generator-index --save
npm install hexo-generator-archive --save
npm install hexo-generator-category --save
npm install hexo-generator-tag --save
npm install hexo-server --save
npm install hexo-deployer-git --save
npm install hexo-deployer-heroku --save
npm install hexo-deployer-rsync --save
npm install hexo-deployer-openshift --save
npm install hexo-renderer-marked@0.2 --save
npm install hexo-renderer-stylus@0.2 --save
npm install hexo-generator-feed@1 --save
npm install hexo-generator-sitemap@1 --save
</code></pre><h2 id="将当前工程上传到github"><a href="#将当前工程上传到github" class="headerlink" title="将当前工程上传到github"></a>将当前工程上传到github</h2><h3 id="1-修改配置文件："><a href="#1-修改配置文件：" class="headerlink" title="1.修改配置文件："></a>1.修改配置文件：</h3><p>在当前项目的根目录下找到<code>_config.yml</code>配置文件，用编辑器打开，并找到Deployment标签处deploy节点，填写以下配置信息，<code>type</code>是指定拖过平台类型，<code>repository</code>指定了github上创建的repository仓库地址，<code>branch</code>指定了版本类型。（注：冒号后面需要加一个空格，否则会出现报错）</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: github
  repository: https://github.com/linshuhe1/linshuhe1.github.io.git
  branch: master
</code></pre><h3 id="2-将项目deploy到github仓库："><a href="#2-将项目deploy到github仓库：" class="headerlink" title="2.将项目deploy到github仓库："></a>2.将项目deploy到github仓库：</h3><p>打开Git shell进入当前项目的根目录，依次执行指令：</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre><p>一般执行最后一步的时候会出现错误如下：<br><img src="http://i.imgur.com/68SebBI.png" alt=""><br>解决错误的方法是：将deploy的type改成git，然后在Git shell中执行：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>执行结束后再次执行上述三个指令，正确结果应该如下：<br><img src="http://i.imgur.com/G0wPCXU.png" alt=""><br>如此我们便完成了将本地的hexo工程deploy到github上的操作，访问地址：<a href="https://username.github.io/可以看到页面效果,这里以我的github为例：[https://linshuhe1.github.io/](https://linshuhe1.github.io/" target="_blank" rel="external">https://username.github.io/可以看到页面效果,这里以我的github为例：[https://linshuhe1.github.io/](https://linshuhe1.github.io/</a> “<a href="https://linshuhe1.github.io/&quot;)。" target="_blank" rel="external">https://linshuhe1.github.io/&quot;)。</a></p>
<h2 id="Hexo常用指令使用："><a href="#Hexo常用指令使用：" class="headerlink" title="Hexo常用指令使用："></a>Hexo常用指令使用：</h2><h3 id="创建新博文："><a href="#创建新博文：" class="headerlink" title="创建新博文："></a>创建新博文：</h3><p>在Git shell中使用以下指令：</p>
<pre><code>hexo new &quot;postName&quot;
</code></pre><p>生成指定名称postName的文章到hexo\source_posts\postName.md，当然也可以直接到hexo\source_posts目录下，手动创建一个文件，命名时注意后缀名必须是“.md”即可。<br><img src="http://i.imgur.com/qjVQtnG.png" alt=""><br>可以打开查看新建出来的.md文件的内容：</p>
<pre><code>---
title: github pages + Hexo
date: 2016-09-02 17:17:52
tags:
---
</code></pre><p><code>title</code>是博文的标题，<code>date</code>是博文的日期，<code>tags</code>是分类标签。</p>
<p>更详细的内容可以参考：<a href="https://hexo.io/docs/writing.html" title="Writing" target="_blank" rel="external">https://hexo.io/docs/writing.html</a></p>
<h3 id="新建页面："><a href="#新建页面：" class="headerlink" title="新建页面："></a>新建页面：</h3><p>上面的步骤其实就是新建一篇博文的步骤，他们最后都是通过一个文章页面来显示的单个子页，但是我们的博客页面出来需要有博文显示页面之后，还需要有其他的页面，每个页面相当于一个分类对应顶栏菜单中的一个页签，如下图首页、下载等都是一个页面，所以可以理解为页面就相当于子页的父节点：<br><img src="http://i.imgur.com/V33kn9P.png" alt=""><br>创建一个页签的操作是在Git shell中输入指令：</p>
<pre><code>hexo new page &quot;页签名称&quot;
</code></pre><p>上述步骤操作结果是在hexo\source目录下多出一个文件夹，而且里面还有一个index.md，这就表明了我们新建了一个页签。</p>
<h3 id="运行博客："><a href="#运行博客：" class="headerlink" title="运行博客："></a>运行博客：</h3><p>使用Git shell在当前项目的根目录下执行以下指令：</p>
<pre><code>hexo server
</code></pre><p>更详细的内容可以参考：<a href="http://hexo.io/docs/server.html" title="Server" target="_blank" rel="external">http://hexo.io/docs/server.html</a></p>
<h3 id="生成静态站点文件："><a href="#生成静态站点文件：" class="headerlink" title="生成静态站点文件："></a>生成静态站点文件：</h3><pre><code>hexo generate
</code></pre><p>更详细的内容可以参考：<a href="http://hexo.io/docs/generating.html" title="Generating" target="_blank" rel="external">http://hexo.io/docs/generating.html</a></p>
<h2 id="发表一篇新博文"><a href="#发表一篇新博文" class="headerlink" title="发表一篇新博文"></a>发表一篇新博文</h2><h3 id="1-新建博文："><a href="#1-新建博文：" class="headerlink" title="1.新建博文："></a>1.新建博文：</h3><p>使用新建博文的指令：</p>
<pre><code>hexo new &quot;github pages + Hexo&quot;
</code></pre><h3 id="2-编辑博文内容："><a href="#2-编辑博文内容：" class="headerlink" title="2.编辑博文内容："></a>2.编辑博文内容：</h3><p>打开步骤1创建得到的.md文件，使用的语法是markdown，假设内容如下：</p>
<pre><code>---
title: github pages + Hexo
date: 2016-09-02 17:17:52
tags: 测试
---

&gt;测试博客
</code></pre><h3 id="3-发表博文："><a href="#3-发表博文：" class="headerlink" title="3.发表博文："></a>3.发表博文：</h3><p>之前的内容中已经提到了将本地内容更新到github需要三个步骤：</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre><p>其实还有快捷的指令输入方式，如下：</p>
<pre><code>hexo g == hexo generate
hexo d == hexo deploy
hexo s == hexo server
hexo n == hexo new
# 还能组合使用，如：
hexo d -g
</code></pre><p>完成上述三个步骤，一篇新的博文就发表到github上面了。</p>
<h2 id="使用Next主题美化界面："><a href="#使用Next主题美化界面：" class="headerlink" title="使用Next主题美化界面："></a>使用Next主题美化界面：</h2><p>安装好hexo之后，主题使用的是hexo默认自带的<code>landscape</code>主题，Next主题是iissnan设计的，使用指南其实可以直接参考Next官方网：<a href="http://theme-next.iissnan.com/" title="Next" target="_blank" rel="external">http://theme-next.iissnan.com/</a></p>
<h3 id="1-Next主题下载："><a href="#1-Next主题下载：" class="headerlink" title="1.Next主题下载："></a>1.Next主题下载：</h3><p>打开Git shell，在当前项目根目下使用git从github上checkout主题的代码，输入指令：</p>
<pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p><img src="http://i.imgur.com/bGoWtvn.png" alt=""><br>下载完成后，在hexo\theme目录下回多出一个next文件夹，里面就是next主题所需的文件,当然我们也可以看到在theme文件目录还有一个landscape文件夹，这也就是hexo默认的主题。<br><img src="http://i.imgur.com/rqq71ts.png" alt=""></p>
<h3 id="2-配置主题："><a href="#2-配置主题：" class="headerlink" title="2.配置主题："></a>2.配置主题：</h3><p>之前我们配置hexo的时候，有用到<code>_config.yml</code>文件，称其为<strong>站点配置文件</strong>，而我们打开next主题文件夹，发现里面也有一个<code>_config.yml</code>文件，我们称这个为<strong>主题配置文件</strong>。在hexo中启用next主题的方式：就是打开站点配置文件，找到<code>theme</code>字段，将其值改为“next”，如下：</p>
<pre><code># Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: next
</code></pre><p>配置完成后，在Git shell中使用<code>hexo server</code>指令启动本地博客，在浏览器中访问<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>可以看到如下结果：<br><img src="http://i.imgur.com/ZKzamkL.png" alt=""></p>
<h3 id="3-next的样式选择："><a href="#3-next的样式选择：" class="headerlink" title="3.next的样式选择："></a>3.next的样式选择：</h3><p>next的样式其实有三种：Muse、Mist和Pisces，步骤2中看到的其实是next默认的模式Muse，根据官方说明三个样式的特点如下：</p>
<ul>
<li><strong>Muse：</strong> 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li><strong>Mist：</strong> Muse 的紧凑版本，整洁有序的单栏外观</li>
<li><strong>Pisces：</strong> 双栏 Scheme，小家碧玉似的清新</li>
</ul>
<p>切换的控制其实很简单，使用next主题配置文件中的<code>scheme</code>字段来控制，假设我们选择Mist样式（个人认为最好看的样式），操作步骤是：打开next文件夹中的<code>_config.yml</code>文件，找到<code>scheme</code>字段，将其设置为“Mist”，如下所示：</p>
<pre><code># ------------------------------------------------------
# Scheme Settings
# ------------------------------------------------------

# Schemes
#scheme: Muse
scheme: Mist
#scheme: Pisces
</code></pre><p>重新启动博客，刷新浏览器可以看到：<br><img src="http://i.imgur.com/6YFzhyz.png" alt=""></p>
<h2 id="额外的优化："><a href="#额外的优化：" class="headerlink" title="额外的优化："></a>额外的优化：</h2><h3 id="1-设置favicon："><a href="#1-设置favicon：" class="headerlink" title="1.设置favicon："></a>1.设置favicon：</h3><p>favicon的全称Favorites Icon，即地址栏左侧的图标：</p>
<p><img src="http://i.imgur.com/ZNLKFAE.png" alt=""></p>
<p>有个在线工具可以上传自己的图片去生成指定规格的favicon.ico文件：<a href="http://www.atool.org/ico.php" target="_blank" rel="external">http://www.atool.org/ico.php</a>。打开主题配置文件<code>_config.yml</code>可以看到favicon的配置信息：</p>
<pre><code># Put your favicon.ico into `hexo-site/source/` directory.
favicon: /favicon.ico
</code></pre><p>根据说明，我们将图标取名为<code>favicon.ico</code>然后放到当前工程的hexo\source目录下，重启博客即可生效。</p>
<h3 id="2-菜单栏控制："><a href="#2-菜单栏控制：" class="headerlink" title="2.菜单栏控制："></a>2.菜单栏控制：</h3><p>我们看到页面顶部的菜单栏，其实是由主题配置文件中的<code>menu</code>字段控制的，例如原本的样子是这样：<br><img src="http://i.imgur.com/iyg45Yj.png" alt=""></p>
<p>我们修改一下主题配置文件，如下把about页面前面的注释去掉，即让此页签处于显示状态：</p>
<pre><code># ------------------------------------------------------
# Menu Settings
# ------------------------------------------------------

# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)
menu:
  home: /
  #categories: /categories
  about: /about
  archives: /archives
  tags: /tags
  #commonweal: /404.html
</code></pre><p>重启博客可以看到效果如下：<br><img src="http://i.imgur.com/O6Z9NvT.png" alt=""></p>
<p>然而，点击打开About却出现了“Cannot GET /about/”的页面错误，这是因为我们还没有about这个页面，需要使用<code>hexo new page &quot;页面名称&quot;</code>进行创建：</p>
<pre><code>hexo new page about
</code></pre><p>执行结果就是在hexo\source目录下面多出了一个about文件夹，里面有index.md，这就是点击About会展示的内容页面。同理，也可以创建tags页面。</p>
<h3 id="3-语言设置："><a href="#3-语言设置：" class="headerlink" title="3.语言设置："></a>3.语言设置：</h3><p>在站点配置文件中假如如下内容，明确指定使用的语言，例如中文：</p>
<pre><code>language: zh-Hans
</code></pre><p>设置完毕后，发现菜单栏也发生了变化：<br><img src="http://i.imgur.com/Ekxi8Tv.png" alt=""></p>
<h3 id="4-侧栏设置："><a href="#4-侧栏设置：" class="headerlink" title="4.侧栏设置："></a>4.侧栏设置：</h3><p>在主题配置文件的<code>sidebar</code>字段，此处我直接设置为侧栏一直显示，而且显示在右边：</p>
<pre><code>sidebar:
  # Sidebar Position, available value: left | right
  position: left
  #position: right

  # Sidebar Display, available value:
  #  - post    expand on posts automatically. Default.
  #  - always  expand for all pages automatically
  #  - hide    expand only when click on the sidebar toggle icon.
  #  - remove  Totally remove sidebar including sidebar toggler.
  #display: post
  display: always
  #display: hide
  #display: remove
</code></pre><h3 id="5-设置头像和作者名称："><a href="#5-设置头像和作者名称：" class="headerlink" title="5.设置头像和作者名称："></a>5.设置头像和作者名称：</h3><p>在站点配置文件中，新加一个字段<code>avatar</code>，值就是头像的连接地址，这里我使用站内地址，将avatar.png放到本地目录hexo\source\images中；作者名称直接设置站点配置文件中<code>author</code>字段的值：</p>
<pre><code># Site
title: Linsh-何乐不为~
subtitle:
description:
author: Linshuhe
avatar: /images/avatar.png
language: zh-Hans
timezone:
</code></pre><h2 id="第三方服务："><a href="#第三方服务：" class="headerlink" title="第三方服务："></a>第三方服务：</h2><h3 id="1-多说评论："><a href="#1-多说评论：" class="headerlink" title="1.多说评论："></a>1.多说评论：</h3><p>进入多说官网，登录后点击“我要登录”，填写相关信息，注意要记住<code>多说域名</code>这个字段填写的内容，<code>http://(duoshuo_shortname).duoshuo.com</code>，这个duoshuo_shortname将用于我们站点配置文件中的配置。步骤：在站点配置文件中新建一个<code>duoshuo_shortname</code>的字段，填写注册使用的duoshuo_shortname，例如：</p>
<pre><code>duoshuo_shortname: linshuhe1
</code></pre><h3 id="2-百度统计："><a href="#2-百度统计：" class="headerlink" title="2.百度统计："></a>2.百度统计：</h3><p>用于统计阅读的次数，步骤如下：</p>
<ul>
<li>登录百度统计官网：<a href="http://tongji.baidu.com/web/welcome/login" title="百度统计" target="_blank" rel="external">http://tongji.baidu.com/web/welcome/login</a>定位到站点的代码获取页面；</li>
<li>复制<code>hm.js?</code>后面的那串id；</li>
<li>在站点配置文件中，新增一个字段<code>baidu_analytics</code>，设置其值为上面复制的百度统计的id</li>
<li>阅读次数统计，使用LeanCloud来实现，详情查看：<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="external">https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud</a></li>
</ul>
<h3 id="3-Swiftype搜索"><a href="#3-Swiftype搜索" class="headerlink" title="3.Swiftype搜索"></a>3.Swiftype搜索</h3><p>使用 Swiftype 之前需要前往 Swiftype 配置一个搜索引擎。 而后编辑 站点配置文件， 新增 swiftype_key 字段，值为你的 swiftype 搜索引擎的 key。 详细的配置请参考： <a href="http://theme-next.iissnan.com/third-party-services.html#swfitype" title="Swiftype" target="_blank" rel="external">http://theme-next.iissnan.com/third-party-services.html#swfitype</a></p>
<p><strong>Local Search:</strong>添加百度/谷歌/本地 自定义站点内容搜索：</p>
<ul>
<li>安装hexo-generator-search:</li>
<li>  npm install hexo-generator-search –save</li>
<li>在站点配置文件中加入：</li>
<li>  search:<pre><code>path: search.xml
field: post
</code></pre></li>
</ul>
<blockquote>
<p>最终结果可以查看我的博客：<a href="https://linshuhe1.github.io/" target="_blank" rel="external">https://linshuhe1.github.io/</a></p>
</blockquote>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>可能有人跟我一样遇到了带你麻烦，那就是主页面的文章列表中，博客内容全部显示出来而不是只显示文章一部分和 <code>阅读全文》</code> 按钮，这样显得首页的列表很杂乱和冗长，其实要解决这个问题很简单，只需要在我们编写markdown内容的时候，在适当的位置假如如下标签：</p>
<pre><code>&lt;!--more--&gt;
</code></pre><p>那么在首页显示的部分就是此标签前面的文章内容，而非全文显示：<br><img src="http://i.imgur.com/PIN0F0K.png" alt=""></p>
]]></content>
    </entry>
    
  
  
</search>
